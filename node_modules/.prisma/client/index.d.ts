
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model TipoVeiculo
 * 
 */
export type TipoVeiculo = {
  Id: number
  Descricao: string
  QtdeLugares: number
}

/**
 * Model Pessoa
 * 
 */
export type Pessoa = {
  Id: number
  Nome: string
  Apelido: string
  Celular: string
}

/**
 * Model Veiculo
 * 
 */
export type Veiculo = {
  Id: number
  IdTipoVeiculo: number
  IdMotorista: number
  Apelido: string
}

/**
 * Model Reserva
 * 
 */
export type Reserva = {
  Id: number
  IdVeiculo: number
  QtdeLugaresOcupados: number
  DataHoraSaida: Date
  DataReserva: Date
  DataHoraChegadaPrevista: Date
  Tolerancia: number
}

/**
 * Model PessoaReserva
 * 
 */
export type PessoaReserva = {
  Id: number
  IdPessoa: number
  IdReserva: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TipoVeiculos
 * const tipoVeiculos = await prisma.tipoVeiculo.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TipoVeiculos
   * const tipoVeiculos = await prisma.tipoVeiculo.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.tipoVeiculo`: Exposes CRUD operations for the **TipoVeiculo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoVeiculos
    * const tipoVeiculos = await prisma.tipoVeiculo.findMany()
    * ```
    */
  get tipoVeiculo(): Prisma.TipoVeiculoDelegate<GlobalReject>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **Pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.PessoaDelegate<GlobalReject>;

  /**
   * `prisma.veiculo`: Exposes CRUD operations for the **Veiculo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veiculos
    * const veiculos = await prisma.veiculo.findMany()
    * ```
    */
  get veiculo(): Prisma.VeiculoDelegate<GlobalReject>;

  /**
   * `prisma.reserva`: Exposes CRUD operations for the **Reserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservas
    * const reservas = await prisma.reserva.findMany()
    * ```
    */
  get reserva(): Prisma.ReservaDelegate<GlobalReject>;

  /**
   * `prisma.pessoaReserva`: Exposes CRUD operations for the **PessoaReserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaReservas
    * const pessoaReservas = await prisma.pessoaReserva.findMany()
    * ```
    */
  get pessoaReserva(): Prisma.PessoaReservaDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TipoVeiculo: 'TipoVeiculo',
    Pessoa: 'Pessoa',
    Veiculo: 'Veiculo',
    Reserva: 'Reserva',
    PessoaReserva: 'PessoaReserva'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TipoVeiculoCountOutputType
   */


  export type TipoVeiculoCountOutputType = {
    veiculos: number
  }

  export type TipoVeiculoCountOutputTypeSelect = {
    veiculos?: boolean
  }

  export type TipoVeiculoCountOutputTypeGetPayload<S extends boolean | null | undefined | TipoVeiculoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TipoVeiculoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TipoVeiculoCountOutputTypeArgs)
    ? TipoVeiculoCountOutputType 
    : S extends { select: any } & (TipoVeiculoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TipoVeiculoCountOutputType ? TipoVeiculoCountOutputType[P] : never
  } 
      : TipoVeiculoCountOutputType




  // Custom InputTypes

  /**
   * TipoVeiculoCountOutputType without action
   */
  export type TipoVeiculoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculoCountOutputType
     */
    select?: TipoVeiculoCountOutputTypeSelect | null
  }



  /**
   * Count Type PessoaCountOutputType
   */


  export type PessoaCountOutputType = {
    Veiculo: number
    PessoaReserva: number
  }

  export type PessoaCountOutputTypeSelect = {
    Veiculo?: boolean
    PessoaReserva?: boolean
  }

  export type PessoaCountOutputTypeGetPayload<S extends boolean | null | undefined | PessoaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PessoaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PessoaCountOutputTypeArgs)
    ? PessoaCountOutputType 
    : S extends { select: any } & (PessoaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PessoaCountOutputType ? PessoaCountOutputType[P] : never
  } 
      : PessoaCountOutputType




  // Custom InputTypes

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     */
    select?: PessoaCountOutputTypeSelect | null
  }



  /**
   * Count Type VeiculoCountOutputType
   */


  export type VeiculoCountOutputType = {
    Reserva: number
  }

  export type VeiculoCountOutputTypeSelect = {
    Reserva?: boolean
  }

  export type VeiculoCountOutputTypeGetPayload<S extends boolean | null | undefined | VeiculoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VeiculoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VeiculoCountOutputTypeArgs)
    ? VeiculoCountOutputType 
    : S extends { select: any } & (VeiculoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VeiculoCountOutputType ? VeiculoCountOutputType[P] : never
  } 
      : VeiculoCountOutputType




  // Custom InputTypes

  /**
   * VeiculoCountOutputType without action
   */
  export type VeiculoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VeiculoCountOutputType
     */
    select?: VeiculoCountOutputTypeSelect | null
  }



  /**
   * Count Type ReservaCountOutputType
   */


  export type ReservaCountOutputType = {
    PessoaReserva: number
  }

  export type ReservaCountOutputTypeSelect = {
    PessoaReserva?: boolean
  }

  export type ReservaCountOutputTypeGetPayload<S extends boolean | null | undefined | ReservaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReservaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReservaCountOutputTypeArgs)
    ? ReservaCountOutputType 
    : S extends { select: any } & (ReservaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReservaCountOutputType ? ReservaCountOutputType[P] : never
  } 
      : ReservaCountOutputType




  // Custom InputTypes

  /**
   * ReservaCountOutputType without action
   */
  export type ReservaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReservaCountOutputType
     */
    select?: ReservaCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model TipoVeiculo
   */


  export type AggregateTipoVeiculo = {
    _count: TipoVeiculoCountAggregateOutputType | null
    _avg: TipoVeiculoAvgAggregateOutputType | null
    _sum: TipoVeiculoSumAggregateOutputType | null
    _min: TipoVeiculoMinAggregateOutputType | null
    _max: TipoVeiculoMaxAggregateOutputType | null
  }

  export type TipoVeiculoAvgAggregateOutputType = {
    Id: number | null
    QtdeLugares: number | null
  }

  export type TipoVeiculoSumAggregateOutputType = {
    Id: number | null
    QtdeLugares: number | null
  }

  export type TipoVeiculoMinAggregateOutputType = {
    Id: number | null
    Descricao: string | null
    QtdeLugares: number | null
  }

  export type TipoVeiculoMaxAggregateOutputType = {
    Id: number | null
    Descricao: string | null
    QtdeLugares: number | null
  }

  export type TipoVeiculoCountAggregateOutputType = {
    Id: number
    Descricao: number
    QtdeLugares: number
    _all: number
  }


  export type TipoVeiculoAvgAggregateInputType = {
    Id?: true
    QtdeLugares?: true
  }

  export type TipoVeiculoSumAggregateInputType = {
    Id?: true
    QtdeLugares?: true
  }

  export type TipoVeiculoMinAggregateInputType = {
    Id?: true
    Descricao?: true
    QtdeLugares?: true
  }

  export type TipoVeiculoMaxAggregateInputType = {
    Id?: true
    Descricao?: true
    QtdeLugares?: true
  }

  export type TipoVeiculoCountAggregateInputType = {
    Id?: true
    Descricao?: true
    QtdeLugares?: true
    _all?: true
  }

  export type TipoVeiculoAggregateArgs = {
    /**
     * Filter which TipoVeiculo to aggregate.
     */
    where?: TipoVeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoVeiculos to fetch.
     */
    orderBy?: Enumerable<TipoVeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoVeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoVeiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoVeiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoVeiculos
    **/
    _count?: true | TipoVeiculoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoVeiculoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoVeiculoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoVeiculoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoVeiculoMaxAggregateInputType
  }

  export type GetTipoVeiculoAggregateType<T extends TipoVeiculoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoVeiculo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoVeiculo[P]>
      : GetScalarType<T[P], AggregateTipoVeiculo[P]>
  }




  export type TipoVeiculoGroupByArgs = {
    where?: TipoVeiculoWhereInput
    orderBy?: Enumerable<TipoVeiculoOrderByWithAggregationInput>
    by: TipoVeiculoScalarFieldEnum[]
    having?: TipoVeiculoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoVeiculoCountAggregateInputType | true
    _avg?: TipoVeiculoAvgAggregateInputType
    _sum?: TipoVeiculoSumAggregateInputType
    _min?: TipoVeiculoMinAggregateInputType
    _max?: TipoVeiculoMaxAggregateInputType
  }


  export type TipoVeiculoGroupByOutputType = {
    Id: number
    Descricao: string
    QtdeLugares: number
    _count: TipoVeiculoCountAggregateOutputType | null
    _avg: TipoVeiculoAvgAggregateOutputType | null
    _sum: TipoVeiculoSumAggregateOutputType | null
    _min: TipoVeiculoMinAggregateOutputType | null
    _max: TipoVeiculoMaxAggregateOutputType | null
  }

  type GetTipoVeiculoGroupByPayload<T extends TipoVeiculoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TipoVeiculoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoVeiculoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoVeiculoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoVeiculoGroupByOutputType[P]>
        }
      >
    >


  export type TipoVeiculoSelect = {
    Id?: boolean
    Descricao?: boolean
    QtdeLugares?: boolean
    veiculos?: boolean | TipoVeiculo$veiculosArgs
    _count?: boolean | TipoVeiculoCountOutputTypeArgs
  }


  export type TipoVeiculoInclude = {
    veiculos?: boolean | TipoVeiculo$veiculosArgs
    _count?: boolean | TipoVeiculoCountOutputTypeArgs
  }

  export type TipoVeiculoGetPayload<S extends boolean | null | undefined | TipoVeiculoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TipoVeiculo :
    S extends undefined ? never :
    S extends { include: any } & (TipoVeiculoArgs | TipoVeiculoFindManyArgs)
    ? TipoVeiculo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'veiculos' ? Array < VeiculoGetPayload<S['include'][P]>>  :
        P extends '_count' ? TipoVeiculoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TipoVeiculoArgs | TipoVeiculoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'veiculos' ? Array < VeiculoGetPayload<S['select'][P]>>  :
        P extends '_count' ? TipoVeiculoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TipoVeiculo ? TipoVeiculo[P] : never
  } 
      : TipoVeiculo


  type TipoVeiculoCountArgs = 
    Omit<TipoVeiculoFindManyArgs, 'select' | 'include'> & {
      select?: TipoVeiculoCountAggregateInputType | true
    }

  export interface TipoVeiculoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TipoVeiculo that matches the filter.
     * @param {TipoVeiculoFindUniqueArgs} args - Arguments to find a TipoVeiculo
     * @example
     * // Get one TipoVeiculo
     * const tipoVeiculo = await prisma.tipoVeiculo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoVeiculoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoVeiculoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TipoVeiculo'> extends True ? Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>> : Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T> | null, null>

    /**
     * Find one TipoVeiculo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TipoVeiculoFindUniqueOrThrowArgs} args - Arguments to find a TipoVeiculo
     * @example
     * // Get one TipoVeiculo
     * const tipoVeiculo = await prisma.tipoVeiculo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoVeiculoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TipoVeiculoFindUniqueOrThrowArgs>
    ): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>>

    /**
     * Find the first TipoVeiculo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoFindFirstArgs} args - Arguments to find a TipoVeiculo
     * @example
     * // Get one TipoVeiculo
     * const tipoVeiculo = await prisma.tipoVeiculo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoVeiculoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoVeiculoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TipoVeiculo'> extends True ? Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>> : Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T> | null, null>

    /**
     * Find the first TipoVeiculo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoFindFirstOrThrowArgs} args - Arguments to find a TipoVeiculo
     * @example
     * // Get one TipoVeiculo
     * const tipoVeiculo = await prisma.tipoVeiculo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoVeiculoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TipoVeiculoFindFirstOrThrowArgs>
    ): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>>

    /**
     * Find zero or more TipoVeiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoVeiculos
     * const tipoVeiculos = await prisma.tipoVeiculo.findMany()
     * 
     * // Get first 10 TipoVeiculos
     * const tipoVeiculos = await prisma.tipoVeiculo.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const tipoVeiculoWithIdOnly = await prisma.tipoVeiculo.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends TipoVeiculoFindManyArgs>(
      args?: SelectSubset<T, TipoVeiculoFindManyArgs>
    ): Prisma.PrismaPromise<Array<TipoVeiculoGetPayload<T>>>

    /**
     * Create a TipoVeiculo.
     * @param {TipoVeiculoCreateArgs} args - Arguments to create a TipoVeiculo.
     * @example
     * // Create one TipoVeiculo
     * const TipoVeiculo = await prisma.tipoVeiculo.create({
     *   data: {
     *     // ... data to create a TipoVeiculo
     *   }
     * })
     * 
    **/
    create<T extends TipoVeiculoCreateArgs>(
      args: SelectSubset<T, TipoVeiculoCreateArgs>
    ): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>>

    /**
     * Create many TipoVeiculos.
     *     @param {TipoVeiculoCreateManyArgs} args - Arguments to create many TipoVeiculos.
     *     @example
     *     // Create many TipoVeiculos
     *     const tipoVeiculo = await prisma.tipoVeiculo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoVeiculoCreateManyArgs>(
      args?: SelectSubset<T, TipoVeiculoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TipoVeiculo.
     * @param {TipoVeiculoDeleteArgs} args - Arguments to delete one TipoVeiculo.
     * @example
     * // Delete one TipoVeiculo
     * const TipoVeiculo = await prisma.tipoVeiculo.delete({
     *   where: {
     *     // ... filter to delete one TipoVeiculo
     *   }
     * })
     * 
    **/
    delete<T extends TipoVeiculoDeleteArgs>(
      args: SelectSubset<T, TipoVeiculoDeleteArgs>
    ): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>>

    /**
     * Update one TipoVeiculo.
     * @param {TipoVeiculoUpdateArgs} args - Arguments to update one TipoVeiculo.
     * @example
     * // Update one TipoVeiculo
     * const tipoVeiculo = await prisma.tipoVeiculo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoVeiculoUpdateArgs>(
      args: SelectSubset<T, TipoVeiculoUpdateArgs>
    ): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>>

    /**
     * Delete zero or more TipoVeiculos.
     * @param {TipoVeiculoDeleteManyArgs} args - Arguments to filter TipoVeiculos to delete.
     * @example
     * // Delete a few TipoVeiculos
     * const { count } = await prisma.tipoVeiculo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoVeiculoDeleteManyArgs>(
      args?: SelectSubset<T, TipoVeiculoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoVeiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoVeiculos
     * const tipoVeiculo = await prisma.tipoVeiculo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoVeiculoUpdateManyArgs>(
      args: SelectSubset<T, TipoVeiculoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoVeiculo.
     * @param {TipoVeiculoUpsertArgs} args - Arguments to update or create a TipoVeiculo.
     * @example
     * // Update or create a TipoVeiculo
     * const tipoVeiculo = await prisma.tipoVeiculo.upsert({
     *   create: {
     *     // ... data to create a TipoVeiculo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoVeiculo we want to update
     *   }
     * })
    **/
    upsert<T extends TipoVeiculoUpsertArgs>(
      args: SelectSubset<T, TipoVeiculoUpsertArgs>
    ): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T>>

    /**
     * Count the number of TipoVeiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoCountArgs} args - Arguments to filter TipoVeiculos to count.
     * @example
     * // Count the number of TipoVeiculos
     * const count = await prisma.tipoVeiculo.count({
     *   where: {
     *     // ... the filter for the TipoVeiculos we want to count
     *   }
     * })
    **/
    count<T extends TipoVeiculoCountArgs>(
      args?: Subset<T, TipoVeiculoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoVeiculoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoVeiculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoVeiculoAggregateArgs>(args: Subset<T, TipoVeiculoAggregateArgs>): Prisma.PrismaPromise<GetTipoVeiculoAggregateType<T>>

    /**
     * Group by TipoVeiculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoVeiculoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoVeiculoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoVeiculoGroupByArgs['orderBy'] }
        : { orderBy?: TipoVeiculoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoVeiculoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoVeiculoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoVeiculo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoVeiculoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    veiculos<T extends TipoVeiculo$veiculosArgs= {}>(args?: Subset<T, TipoVeiculo$veiculosArgs>): Prisma.PrismaPromise<Array<VeiculoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TipoVeiculo base type for findUnique actions
   */
  export type TipoVeiculoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * Filter, which TipoVeiculo to fetch.
     */
    where: TipoVeiculoWhereUniqueInput
  }

  /**
   * TipoVeiculo findUnique
   */
  export interface TipoVeiculoFindUniqueArgs extends TipoVeiculoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoVeiculo findUniqueOrThrow
   */
  export type TipoVeiculoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * Filter, which TipoVeiculo to fetch.
     */
    where: TipoVeiculoWhereUniqueInput
  }


  /**
   * TipoVeiculo base type for findFirst actions
   */
  export type TipoVeiculoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * Filter, which TipoVeiculo to fetch.
     */
    where?: TipoVeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoVeiculos to fetch.
     */
    orderBy?: Enumerable<TipoVeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoVeiculos.
     */
    cursor?: TipoVeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoVeiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoVeiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoVeiculos.
     */
    distinct?: Enumerable<TipoVeiculoScalarFieldEnum>
  }

  /**
   * TipoVeiculo findFirst
   */
  export interface TipoVeiculoFindFirstArgs extends TipoVeiculoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoVeiculo findFirstOrThrow
   */
  export type TipoVeiculoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * Filter, which TipoVeiculo to fetch.
     */
    where?: TipoVeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoVeiculos to fetch.
     */
    orderBy?: Enumerable<TipoVeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoVeiculos.
     */
    cursor?: TipoVeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoVeiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoVeiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoVeiculos.
     */
    distinct?: Enumerable<TipoVeiculoScalarFieldEnum>
  }


  /**
   * TipoVeiculo findMany
   */
  export type TipoVeiculoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * Filter, which TipoVeiculos to fetch.
     */
    where?: TipoVeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoVeiculos to fetch.
     */
    orderBy?: Enumerable<TipoVeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoVeiculos.
     */
    cursor?: TipoVeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoVeiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoVeiculos.
     */
    skip?: number
    distinct?: Enumerable<TipoVeiculoScalarFieldEnum>
  }


  /**
   * TipoVeiculo create
   */
  export type TipoVeiculoCreateArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * The data needed to create a TipoVeiculo.
     */
    data: XOR<TipoVeiculoCreateInput, TipoVeiculoUncheckedCreateInput>
  }


  /**
   * TipoVeiculo createMany
   */
  export type TipoVeiculoCreateManyArgs = {
    /**
     * The data used to create many TipoVeiculos.
     */
    data: Enumerable<TipoVeiculoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TipoVeiculo update
   */
  export type TipoVeiculoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * The data needed to update a TipoVeiculo.
     */
    data: XOR<TipoVeiculoUpdateInput, TipoVeiculoUncheckedUpdateInput>
    /**
     * Choose, which TipoVeiculo to update.
     */
    where: TipoVeiculoWhereUniqueInput
  }


  /**
   * TipoVeiculo updateMany
   */
  export type TipoVeiculoUpdateManyArgs = {
    /**
     * The data used to update TipoVeiculos.
     */
    data: XOR<TipoVeiculoUpdateManyMutationInput, TipoVeiculoUncheckedUpdateManyInput>
    /**
     * Filter which TipoVeiculos to update
     */
    where?: TipoVeiculoWhereInput
  }


  /**
   * TipoVeiculo upsert
   */
  export type TipoVeiculoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * The filter to search for the TipoVeiculo to update in case it exists.
     */
    where: TipoVeiculoWhereUniqueInput
    /**
     * In case the TipoVeiculo found by the `where` argument doesn't exist, create a new TipoVeiculo with this data.
     */
    create: XOR<TipoVeiculoCreateInput, TipoVeiculoUncheckedCreateInput>
    /**
     * In case the TipoVeiculo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoVeiculoUpdateInput, TipoVeiculoUncheckedUpdateInput>
  }


  /**
   * TipoVeiculo delete
   */
  export type TipoVeiculoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
    /**
     * Filter which TipoVeiculo to delete.
     */
    where: TipoVeiculoWhereUniqueInput
  }


  /**
   * TipoVeiculo deleteMany
   */
  export type TipoVeiculoDeleteManyArgs = {
    /**
     * Filter which TipoVeiculos to delete
     */
    where?: TipoVeiculoWhereInput
  }


  /**
   * TipoVeiculo.veiculos
   */
  export type TipoVeiculo$veiculosArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    where?: VeiculoWhereInput
    orderBy?: Enumerable<VeiculoOrderByWithRelationInput>
    cursor?: VeiculoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VeiculoScalarFieldEnum>
  }


  /**
   * TipoVeiculo without action
   */
  export type TipoVeiculoArgs = {
    /**
     * Select specific fields to fetch from the TipoVeiculo
     */
    select?: TipoVeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoVeiculoInclude | null
  }



  /**
   * Model Pessoa
   */


  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    Id: number | null
  }

  export type PessoaSumAggregateOutputType = {
    Id: number | null
  }

  export type PessoaMinAggregateOutputType = {
    Id: number | null
    Nome: string | null
    Apelido: string | null
    Celular: string | null
  }

  export type PessoaMaxAggregateOutputType = {
    Id: number | null
    Nome: string | null
    Apelido: string | null
    Celular: string | null
  }

  export type PessoaCountAggregateOutputType = {
    Id: number
    Nome: number
    Apelido: number
    Celular: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    Id?: true
  }

  export type PessoaSumAggregateInputType = {
    Id?: true
  }

  export type PessoaMinAggregateInputType = {
    Id?: true
    Nome?: true
    Apelido?: true
    Celular?: true
  }

  export type PessoaMaxAggregateInputType = {
    Id?: true
    Nome?: true
    Apelido?: true
    Celular?: true
  }

  export type PessoaCountAggregateInputType = {
    Id?: true
    Nome?: true
    Apelido?: true
    Celular?: true
    _all?: true
  }

  export type PessoaAggregateArgs = {
    /**
     * Filter which Pessoa to aggregate.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type PessoaGroupByArgs = {
    where?: PessoaWhereInput
    orderBy?: Enumerable<PessoaOrderByWithAggregationInput>
    by: PessoaScalarFieldEnum[]
    having?: PessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }


  export type PessoaGroupByOutputType = {
    Id: number
    Nome: string
    Apelido: string
    Celular: string
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends PessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type PessoaSelect = {
    Id?: boolean
    Nome?: boolean
    Apelido?: boolean
    Celular?: boolean
    Veiculo?: boolean | Pessoa$VeiculoArgs
    PessoaReserva?: boolean | Pessoa$PessoaReservaArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  }


  export type PessoaInclude = {
    Veiculo?: boolean | Pessoa$VeiculoArgs
    PessoaReserva?: boolean | Pessoa$PessoaReservaArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  }

  export type PessoaGetPayload<S extends boolean | null | undefined | PessoaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pessoa :
    S extends undefined ? never :
    S extends { include: any } & (PessoaArgs | PessoaFindManyArgs)
    ? Pessoa  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Veiculo' ? Array < VeiculoGetPayload<S['include'][P]>>  :
        P extends 'PessoaReserva' ? Array < PessoaReservaGetPayload<S['include'][P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PessoaArgs | PessoaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Veiculo' ? Array < VeiculoGetPayload<S['select'][P]>>  :
        P extends 'PessoaReserva' ? Array < PessoaReservaGetPayload<S['select'][P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Pessoa ? Pessoa[P] : never
  } 
      : Pessoa


  type PessoaCountArgs = 
    Omit<PessoaFindManyArgs, 'select' | 'include'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface PessoaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {PessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PessoaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PessoaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pessoa'> extends True ? Prisma__PessoaClient<PessoaGetPayload<T>> : Prisma__PessoaClient<PessoaGetPayload<T> | null, null>

    /**
     * Find one Pessoa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PessoaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PessoaFindUniqueOrThrowArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PessoaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PessoaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pessoa'> extends True ? Prisma__PessoaClient<PessoaGetPayload<T>> : Prisma__PessoaClient<PessoaGetPayload<T> | null, null>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PessoaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PessoaFindFirstOrThrowArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends PessoaFindManyArgs>(
      args?: SelectSubset<T, PessoaFindManyArgs>
    ): Prisma.PrismaPromise<Array<PessoaGetPayload<T>>>

    /**
     * Create a Pessoa.
     * @param {PessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
    **/
    create<T extends PessoaCreateArgs>(
      args: SelectSubset<T, PessoaCreateArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Create many Pessoas.
     *     @param {PessoaCreateManyArgs} args - Arguments to create many Pessoas.
     *     @example
     *     // Create many Pessoas
     *     const pessoa = await prisma.pessoa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PessoaCreateManyArgs>(
      args?: SelectSubset<T, PessoaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pessoa.
     * @param {PessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
    **/
    delete<T extends PessoaDeleteArgs>(
      args: SelectSubset<T, PessoaDeleteArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Update one Pessoa.
     * @param {PessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PessoaUpdateArgs>(
      args: SelectSubset<T, PessoaUpdateArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Delete zero or more Pessoas.
     * @param {PessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PessoaDeleteManyArgs>(
      args?: SelectSubset<T, PessoaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PessoaUpdateManyArgs>(
      args: SelectSubset<T, PessoaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {PessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
    **/
    upsert<T extends PessoaUpsertArgs>(
      args: SelectSubset<T, PessoaUpsertArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends PessoaCountArgs>(
      args?: Subset<T, PessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PessoaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Veiculo<T extends Pessoa$VeiculoArgs= {}>(args?: Subset<T, Pessoa$VeiculoArgs>): Prisma.PrismaPromise<Array<VeiculoGetPayload<T>>| Null>;

    PessoaReserva<T extends Pessoa$PessoaReservaArgs= {}>(args?: Subset<T, Pessoa$PessoaReservaArgs>): Prisma.PrismaPromise<Array<PessoaReservaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pessoa base type for findUnique actions
   */
  export type PessoaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa findUnique
   */
  export interface PessoaFindUniqueArgs extends PessoaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pessoa findUniqueOrThrow
   */
  export type PessoaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }


  /**
   * Pessoa base type for findFirst actions
   */
  export type PessoaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }

  /**
   * Pessoa findFirst
   */
  export interface PessoaFindFirstArgs extends PessoaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pessoa findFirstOrThrow
   */
  export type PessoaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * Pessoa findMany
   */
  export type PessoaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoas to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * Pessoa create
   */
  export type PessoaCreateArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * The data needed to create a Pessoa.
     */
    data: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
  }


  /**
   * Pessoa createMany
   */
  export type PessoaCreateManyArgs = {
    /**
     * The data used to create many Pessoas.
     */
    data: Enumerable<PessoaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pessoa update
   */
  export type PessoaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * The data needed to update a Pessoa.
     */
    data: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
    /**
     * Choose, which Pessoa to update.
     */
    where: PessoaWhereUniqueInput
  }


  /**
   * Pessoa updateMany
   */
  export type PessoaUpdateManyArgs = {
    /**
     * The data used to update Pessoas.
     */
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyInput>
    /**
     * Filter which Pessoas to update
     */
    where?: PessoaWhereInput
  }


  /**
   * Pessoa upsert
   */
  export type PessoaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * The filter to search for the Pessoa to update in case it exists.
     */
    where: PessoaWhereUniqueInput
    /**
     * In case the Pessoa found by the `where` argument doesn't exist, create a new Pessoa with this data.
     */
    create: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
    /**
     * In case the Pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
  }


  /**
   * Pessoa delete
   */
  export type PessoaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter which Pessoa to delete.
     */
    where: PessoaWhereUniqueInput
  }


  /**
   * Pessoa deleteMany
   */
  export type PessoaDeleteManyArgs = {
    /**
     * Filter which Pessoas to delete
     */
    where?: PessoaWhereInput
  }


  /**
   * Pessoa.Veiculo
   */
  export type Pessoa$VeiculoArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    where?: VeiculoWhereInput
    orderBy?: Enumerable<VeiculoOrderByWithRelationInput>
    cursor?: VeiculoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VeiculoScalarFieldEnum>
  }


  /**
   * Pessoa.PessoaReserva
   */
  export type Pessoa$PessoaReservaArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    where?: PessoaReservaWhereInput
    orderBy?: Enumerable<PessoaReservaOrderByWithRelationInput>
    cursor?: PessoaReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PessoaReservaScalarFieldEnum>
  }


  /**
   * Pessoa without action
   */
  export type PessoaArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
  }



  /**
   * Model Veiculo
   */


  export type AggregateVeiculo = {
    _count: VeiculoCountAggregateOutputType | null
    _avg: VeiculoAvgAggregateOutputType | null
    _sum: VeiculoSumAggregateOutputType | null
    _min: VeiculoMinAggregateOutputType | null
    _max: VeiculoMaxAggregateOutputType | null
  }

  export type VeiculoAvgAggregateOutputType = {
    Id: number | null
    IdTipoVeiculo: number | null
    IdMotorista: number | null
  }

  export type VeiculoSumAggregateOutputType = {
    Id: number | null
    IdTipoVeiculo: number | null
    IdMotorista: number | null
  }

  export type VeiculoMinAggregateOutputType = {
    Id: number | null
    IdTipoVeiculo: number | null
    IdMotorista: number | null
    Apelido: string | null
  }

  export type VeiculoMaxAggregateOutputType = {
    Id: number | null
    IdTipoVeiculo: number | null
    IdMotorista: number | null
    Apelido: string | null
  }

  export type VeiculoCountAggregateOutputType = {
    Id: number
    IdTipoVeiculo: number
    IdMotorista: number
    Apelido: number
    _all: number
  }


  export type VeiculoAvgAggregateInputType = {
    Id?: true
    IdTipoVeiculo?: true
    IdMotorista?: true
  }

  export type VeiculoSumAggregateInputType = {
    Id?: true
    IdTipoVeiculo?: true
    IdMotorista?: true
  }

  export type VeiculoMinAggregateInputType = {
    Id?: true
    IdTipoVeiculo?: true
    IdMotorista?: true
    Apelido?: true
  }

  export type VeiculoMaxAggregateInputType = {
    Id?: true
    IdTipoVeiculo?: true
    IdMotorista?: true
    Apelido?: true
  }

  export type VeiculoCountAggregateInputType = {
    Id?: true
    IdTipoVeiculo?: true
    IdMotorista?: true
    Apelido?: true
    _all?: true
  }

  export type VeiculoAggregateArgs = {
    /**
     * Filter which Veiculo to aggregate.
     */
    where?: VeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: Enumerable<VeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Veiculos
    **/
    _count?: true | VeiculoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VeiculoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VeiculoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeiculoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeiculoMaxAggregateInputType
  }

  export type GetVeiculoAggregateType<T extends VeiculoAggregateArgs> = {
        [P in keyof T & keyof AggregateVeiculo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeiculo[P]>
      : GetScalarType<T[P], AggregateVeiculo[P]>
  }




  export type VeiculoGroupByArgs = {
    where?: VeiculoWhereInput
    orderBy?: Enumerable<VeiculoOrderByWithAggregationInput>
    by: VeiculoScalarFieldEnum[]
    having?: VeiculoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeiculoCountAggregateInputType | true
    _avg?: VeiculoAvgAggregateInputType
    _sum?: VeiculoSumAggregateInputType
    _min?: VeiculoMinAggregateInputType
    _max?: VeiculoMaxAggregateInputType
  }


  export type VeiculoGroupByOutputType = {
    Id: number
    IdTipoVeiculo: number
    IdMotorista: number
    Apelido: string
    _count: VeiculoCountAggregateOutputType | null
    _avg: VeiculoAvgAggregateOutputType | null
    _sum: VeiculoSumAggregateOutputType | null
    _min: VeiculoMinAggregateOutputType | null
    _max: VeiculoMaxAggregateOutputType | null
  }

  type GetVeiculoGroupByPayload<T extends VeiculoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VeiculoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeiculoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeiculoGroupByOutputType[P]>
            : GetScalarType<T[P], VeiculoGroupByOutputType[P]>
        }
      >
    >


  export type VeiculoSelect = {
    Id?: boolean
    TipoVeiculo?: boolean | TipoVeiculoArgs
    IdTipoVeiculo?: boolean
    Motorista?: boolean | PessoaArgs
    IdMotorista?: boolean
    Apelido?: boolean
    Reserva?: boolean | Veiculo$ReservaArgs
    _count?: boolean | VeiculoCountOutputTypeArgs
  }


  export type VeiculoInclude = {
    TipoVeiculo?: boolean | TipoVeiculoArgs
    Motorista?: boolean | PessoaArgs
    Reserva?: boolean | Veiculo$ReservaArgs
    _count?: boolean | VeiculoCountOutputTypeArgs
  }

  export type VeiculoGetPayload<S extends boolean | null | undefined | VeiculoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Veiculo :
    S extends undefined ? never :
    S extends { include: any } & (VeiculoArgs | VeiculoFindManyArgs)
    ? Veiculo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'TipoVeiculo' ? TipoVeiculoGetPayload<S['include'][P]> :
        P extends 'Motorista' ? PessoaGetPayload<S['include'][P]> :
        P extends 'Reserva' ? Array < ReservaGetPayload<S['include'][P]>>  :
        P extends '_count' ? VeiculoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VeiculoArgs | VeiculoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'TipoVeiculo' ? TipoVeiculoGetPayload<S['select'][P]> :
        P extends 'Motorista' ? PessoaGetPayload<S['select'][P]> :
        P extends 'Reserva' ? Array < ReservaGetPayload<S['select'][P]>>  :
        P extends '_count' ? VeiculoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Veiculo ? Veiculo[P] : never
  } 
      : Veiculo


  type VeiculoCountArgs = 
    Omit<VeiculoFindManyArgs, 'select' | 'include'> & {
      select?: VeiculoCountAggregateInputType | true
    }

  export interface VeiculoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Veiculo that matches the filter.
     * @param {VeiculoFindUniqueArgs} args - Arguments to find a Veiculo
     * @example
     * // Get one Veiculo
     * const veiculo = await prisma.veiculo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VeiculoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VeiculoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Veiculo'> extends True ? Prisma__VeiculoClient<VeiculoGetPayload<T>> : Prisma__VeiculoClient<VeiculoGetPayload<T> | null, null>

    /**
     * Find one Veiculo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VeiculoFindUniqueOrThrowArgs} args - Arguments to find a Veiculo
     * @example
     * // Get one Veiculo
     * const veiculo = await prisma.veiculo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VeiculoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VeiculoFindUniqueOrThrowArgs>
    ): Prisma__VeiculoClient<VeiculoGetPayload<T>>

    /**
     * Find the first Veiculo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoFindFirstArgs} args - Arguments to find a Veiculo
     * @example
     * // Get one Veiculo
     * const veiculo = await prisma.veiculo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VeiculoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VeiculoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Veiculo'> extends True ? Prisma__VeiculoClient<VeiculoGetPayload<T>> : Prisma__VeiculoClient<VeiculoGetPayload<T> | null, null>

    /**
     * Find the first Veiculo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoFindFirstOrThrowArgs} args - Arguments to find a Veiculo
     * @example
     * // Get one Veiculo
     * const veiculo = await prisma.veiculo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VeiculoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VeiculoFindFirstOrThrowArgs>
    ): Prisma__VeiculoClient<VeiculoGetPayload<T>>

    /**
     * Find zero or more Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veiculos
     * const veiculos = await prisma.veiculo.findMany()
     * 
     * // Get first 10 Veiculos
     * const veiculos = await prisma.veiculo.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const veiculoWithIdOnly = await prisma.veiculo.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends VeiculoFindManyArgs>(
      args?: SelectSubset<T, VeiculoFindManyArgs>
    ): Prisma.PrismaPromise<Array<VeiculoGetPayload<T>>>

    /**
     * Create a Veiculo.
     * @param {VeiculoCreateArgs} args - Arguments to create a Veiculo.
     * @example
     * // Create one Veiculo
     * const Veiculo = await prisma.veiculo.create({
     *   data: {
     *     // ... data to create a Veiculo
     *   }
     * })
     * 
    **/
    create<T extends VeiculoCreateArgs>(
      args: SelectSubset<T, VeiculoCreateArgs>
    ): Prisma__VeiculoClient<VeiculoGetPayload<T>>

    /**
     * Create many Veiculos.
     *     @param {VeiculoCreateManyArgs} args - Arguments to create many Veiculos.
     *     @example
     *     // Create many Veiculos
     *     const veiculo = await prisma.veiculo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VeiculoCreateManyArgs>(
      args?: SelectSubset<T, VeiculoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Veiculo.
     * @param {VeiculoDeleteArgs} args - Arguments to delete one Veiculo.
     * @example
     * // Delete one Veiculo
     * const Veiculo = await prisma.veiculo.delete({
     *   where: {
     *     // ... filter to delete one Veiculo
     *   }
     * })
     * 
    **/
    delete<T extends VeiculoDeleteArgs>(
      args: SelectSubset<T, VeiculoDeleteArgs>
    ): Prisma__VeiculoClient<VeiculoGetPayload<T>>

    /**
     * Update one Veiculo.
     * @param {VeiculoUpdateArgs} args - Arguments to update one Veiculo.
     * @example
     * // Update one Veiculo
     * const veiculo = await prisma.veiculo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VeiculoUpdateArgs>(
      args: SelectSubset<T, VeiculoUpdateArgs>
    ): Prisma__VeiculoClient<VeiculoGetPayload<T>>

    /**
     * Delete zero or more Veiculos.
     * @param {VeiculoDeleteManyArgs} args - Arguments to filter Veiculos to delete.
     * @example
     * // Delete a few Veiculos
     * const { count } = await prisma.veiculo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VeiculoDeleteManyArgs>(
      args?: SelectSubset<T, VeiculoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veiculos
     * const veiculo = await prisma.veiculo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VeiculoUpdateManyArgs>(
      args: SelectSubset<T, VeiculoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Veiculo.
     * @param {VeiculoUpsertArgs} args - Arguments to update or create a Veiculo.
     * @example
     * // Update or create a Veiculo
     * const veiculo = await prisma.veiculo.upsert({
     *   create: {
     *     // ... data to create a Veiculo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Veiculo we want to update
     *   }
     * })
    **/
    upsert<T extends VeiculoUpsertArgs>(
      args: SelectSubset<T, VeiculoUpsertArgs>
    ): Prisma__VeiculoClient<VeiculoGetPayload<T>>

    /**
     * Count the number of Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoCountArgs} args - Arguments to filter Veiculos to count.
     * @example
     * // Count the number of Veiculos
     * const count = await prisma.veiculo.count({
     *   where: {
     *     // ... the filter for the Veiculos we want to count
     *   }
     * })
    **/
    count<T extends VeiculoCountArgs>(
      args?: Subset<T, VeiculoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeiculoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Veiculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeiculoAggregateArgs>(args: Subset<T, VeiculoAggregateArgs>): Prisma.PrismaPromise<GetVeiculoAggregateType<T>>

    /**
     * Group by Veiculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VeiculoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VeiculoGroupByArgs['orderBy'] }
        : { orderBy?: VeiculoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VeiculoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeiculoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Veiculo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VeiculoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    TipoVeiculo<T extends TipoVeiculoArgs= {}>(args?: Subset<T, TipoVeiculoArgs>): Prisma__TipoVeiculoClient<TipoVeiculoGetPayload<T> | Null>;

    Motorista<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    Reserva<T extends Veiculo$ReservaArgs= {}>(args?: Subset<T, Veiculo$ReservaArgs>): Prisma.PrismaPromise<Array<ReservaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Veiculo base type for findUnique actions
   */
  export type VeiculoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * Filter, which Veiculo to fetch.
     */
    where: VeiculoWhereUniqueInput
  }

  /**
   * Veiculo findUnique
   */
  export interface VeiculoFindUniqueArgs extends VeiculoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Veiculo findUniqueOrThrow
   */
  export type VeiculoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * Filter, which Veiculo to fetch.
     */
    where: VeiculoWhereUniqueInput
  }


  /**
   * Veiculo base type for findFirst actions
   */
  export type VeiculoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * Filter, which Veiculo to fetch.
     */
    where?: VeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: Enumerable<VeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Veiculos.
     */
    cursor?: VeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Veiculos.
     */
    distinct?: Enumerable<VeiculoScalarFieldEnum>
  }

  /**
   * Veiculo findFirst
   */
  export interface VeiculoFindFirstArgs extends VeiculoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Veiculo findFirstOrThrow
   */
  export type VeiculoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * Filter, which Veiculo to fetch.
     */
    where?: VeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: Enumerable<VeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Veiculos.
     */
    cursor?: VeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Veiculos.
     */
    distinct?: Enumerable<VeiculoScalarFieldEnum>
  }


  /**
   * Veiculo findMany
   */
  export type VeiculoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * Filter, which Veiculos to fetch.
     */
    where?: VeiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: Enumerable<VeiculoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Veiculos.
     */
    cursor?: VeiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    distinct?: Enumerable<VeiculoScalarFieldEnum>
  }


  /**
   * Veiculo create
   */
  export type VeiculoCreateArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * The data needed to create a Veiculo.
     */
    data: XOR<VeiculoCreateInput, VeiculoUncheckedCreateInput>
  }


  /**
   * Veiculo createMany
   */
  export type VeiculoCreateManyArgs = {
    /**
     * The data used to create many Veiculos.
     */
    data: Enumerable<VeiculoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Veiculo update
   */
  export type VeiculoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * The data needed to update a Veiculo.
     */
    data: XOR<VeiculoUpdateInput, VeiculoUncheckedUpdateInput>
    /**
     * Choose, which Veiculo to update.
     */
    where: VeiculoWhereUniqueInput
  }


  /**
   * Veiculo updateMany
   */
  export type VeiculoUpdateManyArgs = {
    /**
     * The data used to update Veiculos.
     */
    data: XOR<VeiculoUpdateManyMutationInput, VeiculoUncheckedUpdateManyInput>
    /**
     * Filter which Veiculos to update
     */
    where?: VeiculoWhereInput
  }


  /**
   * Veiculo upsert
   */
  export type VeiculoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * The filter to search for the Veiculo to update in case it exists.
     */
    where: VeiculoWhereUniqueInput
    /**
     * In case the Veiculo found by the `where` argument doesn't exist, create a new Veiculo with this data.
     */
    create: XOR<VeiculoCreateInput, VeiculoUncheckedCreateInput>
    /**
     * In case the Veiculo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VeiculoUpdateInput, VeiculoUncheckedUpdateInput>
  }


  /**
   * Veiculo delete
   */
  export type VeiculoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
    /**
     * Filter which Veiculo to delete.
     */
    where: VeiculoWhereUniqueInput
  }


  /**
   * Veiculo deleteMany
   */
  export type VeiculoDeleteManyArgs = {
    /**
     * Filter which Veiculos to delete
     */
    where?: VeiculoWhereInput
  }


  /**
   * Veiculo.Reserva
   */
  export type Veiculo$ReservaArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    where?: ReservaWhereInput
    orderBy?: Enumerable<ReservaOrderByWithRelationInput>
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservaScalarFieldEnum>
  }


  /**
   * Veiculo without action
   */
  export type VeiculoArgs = {
    /**
     * Select specific fields to fetch from the Veiculo
     */
    select?: VeiculoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VeiculoInclude | null
  }



  /**
   * Model Reserva
   */


  export type AggregateReserva = {
    _count: ReservaCountAggregateOutputType | null
    _avg: ReservaAvgAggregateOutputType | null
    _sum: ReservaSumAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  export type ReservaAvgAggregateOutputType = {
    Id: number | null
    IdVeiculo: number | null
    QtdeLugaresOcupados: number | null
    Tolerancia: number | null
  }

  export type ReservaSumAggregateOutputType = {
    Id: number | null
    IdVeiculo: number | null
    QtdeLugaresOcupados: number | null
    Tolerancia: number | null
  }

  export type ReservaMinAggregateOutputType = {
    Id: number | null
    IdVeiculo: number | null
    QtdeLugaresOcupados: number | null
    DataHoraSaida: Date | null
    DataReserva: Date | null
    DataHoraChegadaPrevista: Date | null
    Tolerancia: number | null
  }

  export type ReservaMaxAggregateOutputType = {
    Id: number | null
    IdVeiculo: number | null
    QtdeLugaresOcupados: number | null
    DataHoraSaida: Date | null
    DataReserva: Date | null
    DataHoraChegadaPrevista: Date | null
    Tolerancia: number | null
  }

  export type ReservaCountAggregateOutputType = {
    Id: number
    IdVeiculo: number
    QtdeLugaresOcupados: number
    DataHoraSaida: number
    DataReserva: number
    DataHoraChegadaPrevista: number
    Tolerancia: number
    _all: number
  }


  export type ReservaAvgAggregateInputType = {
    Id?: true
    IdVeiculo?: true
    QtdeLugaresOcupados?: true
    Tolerancia?: true
  }

  export type ReservaSumAggregateInputType = {
    Id?: true
    IdVeiculo?: true
    QtdeLugaresOcupados?: true
    Tolerancia?: true
  }

  export type ReservaMinAggregateInputType = {
    Id?: true
    IdVeiculo?: true
    QtdeLugaresOcupados?: true
    DataHoraSaida?: true
    DataReserva?: true
    DataHoraChegadaPrevista?: true
    Tolerancia?: true
  }

  export type ReservaMaxAggregateInputType = {
    Id?: true
    IdVeiculo?: true
    QtdeLugaresOcupados?: true
    DataHoraSaida?: true
    DataReserva?: true
    DataHoraChegadaPrevista?: true
    Tolerancia?: true
  }

  export type ReservaCountAggregateInputType = {
    Id?: true
    IdVeiculo?: true
    QtdeLugaresOcupados?: true
    DataHoraSaida?: true
    DataReserva?: true
    DataHoraChegadaPrevista?: true
    Tolerancia?: true
    _all?: true
  }

  export type ReservaAggregateArgs = {
    /**
     * Filter which Reserva to aggregate.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: Enumerable<ReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservas
    **/
    _count?: true | ReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservaMaxAggregateInputType
  }

  export type GetReservaAggregateType<T extends ReservaAggregateArgs> = {
        [P in keyof T & keyof AggregateReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReserva[P]>
      : GetScalarType<T[P], AggregateReserva[P]>
  }




  export type ReservaGroupByArgs = {
    where?: ReservaWhereInput
    orderBy?: Enumerable<ReservaOrderByWithAggregationInput>
    by: ReservaScalarFieldEnum[]
    having?: ReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservaCountAggregateInputType | true
    _avg?: ReservaAvgAggregateInputType
    _sum?: ReservaSumAggregateInputType
    _min?: ReservaMinAggregateInputType
    _max?: ReservaMaxAggregateInputType
  }


  export type ReservaGroupByOutputType = {
    Id: number
    IdVeiculo: number
    QtdeLugaresOcupados: number
    DataHoraSaida: Date
    DataReserva: Date
    DataHoraChegadaPrevista: Date
    Tolerancia: number
    _count: ReservaCountAggregateOutputType | null
    _avg: ReservaAvgAggregateOutputType | null
    _sum: ReservaSumAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  type GetReservaGroupByPayload<T extends ReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservaGroupByOutputType[P]>
            : GetScalarType<T[P], ReservaGroupByOutputType[P]>
        }
      >
    >


  export type ReservaSelect = {
    Id?: boolean
    Veiculo?: boolean | VeiculoArgs
    IdVeiculo?: boolean
    QtdeLugaresOcupados?: boolean
    DataHoraSaida?: boolean
    DataReserva?: boolean
    DataHoraChegadaPrevista?: boolean
    Tolerancia?: boolean
    PessoaReserva?: boolean | Reserva$PessoaReservaArgs
    _count?: boolean | ReservaCountOutputTypeArgs
  }


  export type ReservaInclude = {
    Veiculo?: boolean | VeiculoArgs
    PessoaReserva?: boolean | Reserva$PessoaReservaArgs
    _count?: boolean | ReservaCountOutputTypeArgs
  }

  export type ReservaGetPayload<S extends boolean | null | undefined | ReservaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Reserva :
    S extends undefined ? never :
    S extends { include: any } & (ReservaArgs | ReservaFindManyArgs)
    ? Reserva  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Veiculo' ? VeiculoGetPayload<S['include'][P]> :
        P extends 'PessoaReserva' ? Array < PessoaReservaGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReservaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReservaArgs | ReservaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Veiculo' ? VeiculoGetPayload<S['select'][P]> :
        P extends 'PessoaReserva' ? Array < PessoaReservaGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReservaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Reserva ? Reserva[P] : never
  } 
      : Reserva


  type ReservaCountArgs = 
    Omit<ReservaFindManyArgs, 'select' | 'include'> & {
      select?: ReservaCountAggregateInputType | true
    }

  export interface ReservaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reserva that matches the filter.
     * @param {ReservaFindUniqueArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReservaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReservaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reserva'> extends True ? Prisma__ReservaClient<ReservaGetPayload<T>> : Prisma__ReservaClient<ReservaGetPayload<T> | null, null>

    /**
     * Find one Reserva that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReservaFindUniqueOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReservaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReservaFindUniqueOrThrowArgs>
    ): Prisma__ReservaClient<ReservaGetPayload<T>>

    /**
     * Find the first Reserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReservaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReservaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reserva'> extends True ? Prisma__ReservaClient<ReservaGetPayload<T>> : Prisma__ReservaClient<ReservaGetPayload<T> | null, null>

    /**
     * Find the first Reserva that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReservaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReservaFindFirstOrThrowArgs>
    ): Prisma__ReservaClient<ReservaGetPayload<T>>

    /**
     * Find zero or more Reservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservas
     * const reservas = await prisma.reserva.findMany()
     * 
     * // Get first 10 Reservas
     * const reservas = await prisma.reserva.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const reservaWithIdOnly = await prisma.reserva.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ReservaFindManyArgs>(
      args?: SelectSubset<T, ReservaFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReservaGetPayload<T>>>

    /**
     * Create a Reserva.
     * @param {ReservaCreateArgs} args - Arguments to create a Reserva.
     * @example
     * // Create one Reserva
     * const Reserva = await prisma.reserva.create({
     *   data: {
     *     // ... data to create a Reserva
     *   }
     * })
     * 
    **/
    create<T extends ReservaCreateArgs>(
      args: SelectSubset<T, ReservaCreateArgs>
    ): Prisma__ReservaClient<ReservaGetPayload<T>>

    /**
     * Create many Reservas.
     *     @param {ReservaCreateManyArgs} args - Arguments to create many Reservas.
     *     @example
     *     // Create many Reservas
     *     const reserva = await prisma.reserva.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReservaCreateManyArgs>(
      args?: SelectSubset<T, ReservaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reserva.
     * @param {ReservaDeleteArgs} args - Arguments to delete one Reserva.
     * @example
     * // Delete one Reserva
     * const Reserva = await prisma.reserva.delete({
     *   where: {
     *     // ... filter to delete one Reserva
     *   }
     * })
     * 
    **/
    delete<T extends ReservaDeleteArgs>(
      args: SelectSubset<T, ReservaDeleteArgs>
    ): Prisma__ReservaClient<ReservaGetPayload<T>>

    /**
     * Update one Reserva.
     * @param {ReservaUpdateArgs} args - Arguments to update one Reserva.
     * @example
     * // Update one Reserva
     * const reserva = await prisma.reserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReservaUpdateArgs>(
      args: SelectSubset<T, ReservaUpdateArgs>
    ): Prisma__ReservaClient<ReservaGetPayload<T>>

    /**
     * Delete zero or more Reservas.
     * @param {ReservaDeleteManyArgs} args - Arguments to filter Reservas to delete.
     * @example
     * // Delete a few Reservas
     * const { count } = await prisma.reserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReservaDeleteManyArgs>(
      args?: SelectSubset<T, ReservaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservas
     * const reserva = await prisma.reserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReservaUpdateManyArgs>(
      args: SelectSubset<T, ReservaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reserva.
     * @param {ReservaUpsertArgs} args - Arguments to update or create a Reserva.
     * @example
     * // Update or create a Reserva
     * const reserva = await prisma.reserva.upsert({
     *   create: {
     *     // ... data to create a Reserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reserva we want to update
     *   }
     * })
    **/
    upsert<T extends ReservaUpsertArgs>(
      args: SelectSubset<T, ReservaUpsertArgs>
    ): Prisma__ReservaClient<ReservaGetPayload<T>>

    /**
     * Count the number of Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaCountArgs} args - Arguments to filter Reservas to count.
     * @example
     * // Count the number of Reservas
     * const count = await prisma.reserva.count({
     *   where: {
     *     // ... the filter for the Reservas we want to count
     *   }
     * })
    **/
    count<T extends ReservaCountArgs>(
      args?: Subset<T, ReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservaAggregateArgs>(args: Subset<T, ReservaAggregateArgs>): Prisma.PrismaPromise<GetReservaAggregateType<T>>

    /**
     * Group by Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservaGroupByArgs['orderBy'] }
        : { orderBy?: ReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReservaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Veiculo<T extends VeiculoArgs= {}>(args?: Subset<T, VeiculoArgs>): Prisma__VeiculoClient<VeiculoGetPayload<T> | Null>;

    PessoaReserva<T extends Reserva$PessoaReservaArgs= {}>(args?: Subset<T, Reserva$PessoaReservaArgs>): Prisma.PrismaPromise<Array<PessoaReservaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reserva base type for findUnique actions
   */
  export type ReservaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findUnique
   */
  export interface ReservaFindUniqueArgs extends ReservaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reserva findUniqueOrThrow
   */
  export type ReservaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }


  /**
   * Reserva base type for findFirst actions
   */
  export type ReservaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: Enumerable<ReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: Enumerable<ReservaScalarFieldEnum>
  }

  /**
   * Reserva findFirst
   */
  export interface ReservaFindFirstArgs extends ReservaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reserva findFirstOrThrow
   */
  export type ReservaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: Enumerable<ReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: Enumerable<ReservaScalarFieldEnum>
  }


  /**
   * Reserva findMany
   */
  export type ReservaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * Filter, which Reservas to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: Enumerable<ReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    distinct?: Enumerable<ReservaScalarFieldEnum>
  }


  /**
   * Reserva create
   */
  export type ReservaCreateArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * The data needed to create a Reserva.
     */
    data: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
  }


  /**
   * Reserva createMany
   */
  export type ReservaCreateManyArgs = {
    /**
     * The data used to create many Reservas.
     */
    data: Enumerable<ReservaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reserva update
   */
  export type ReservaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * The data needed to update a Reserva.
     */
    data: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
    /**
     * Choose, which Reserva to update.
     */
    where: ReservaWhereUniqueInput
  }


  /**
   * Reserva updateMany
   */
  export type ReservaUpdateManyArgs = {
    /**
     * The data used to update Reservas.
     */
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyInput>
    /**
     * Filter which Reservas to update
     */
    where?: ReservaWhereInput
  }


  /**
   * Reserva upsert
   */
  export type ReservaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * The filter to search for the Reserva to update in case it exists.
     */
    where: ReservaWhereUniqueInput
    /**
     * In case the Reserva found by the `where` argument doesn't exist, create a new Reserva with this data.
     */
    create: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
    /**
     * In case the Reserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
  }


  /**
   * Reserva delete
   */
  export type ReservaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
    /**
     * Filter which Reserva to delete.
     */
    where: ReservaWhereUniqueInput
  }


  /**
   * Reserva deleteMany
   */
  export type ReservaDeleteManyArgs = {
    /**
     * Filter which Reservas to delete
     */
    where?: ReservaWhereInput
  }


  /**
   * Reserva.PessoaReserva
   */
  export type Reserva$PessoaReservaArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    where?: PessoaReservaWhereInput
    orderBy?: Enumerable<PessoaReservaOrderByWithRelationInput>
    cursor?: PessoaReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PessoaReservaScalarFieldEnum>
  }


  /**
   * Reserva without action
   */
  export type ReservaArgs = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservaInclude | null
  }



  /**
   * Model PessoaReserva
   */


  export type AggregatePessoaReserva = {
    _count: PessoaReservaCountAggregateOutputType | null
    _avg: PessoaReservaAvgAggregateOutputType | null
    _sum: PessoaReservaSumAggregateOutputType | null
    _min: PessoaReservaMinAggregateOutputType | null
    _max: PessoaReservaMaxAggregateOutputType | null
  }

  export type PessoaReservaAvgAggregateOutputType = {
    Id: number | null
    IdPessoa: number | null
    IdReserva: number | null
  }

  export type PessoaReservaSumAggregateOutputType = {
    Id: number | null
    IdPessoa: number | null
    IdReserva: number | null
  }

  export type PessoaReservaMinAggregateOutputType = {
    Id: number | null
    IdPessoa: number | null
    IdReserva: number | null
  }

  export type PessoaReservaMaxAggregateOutputType = {
    Id: number | null
    IdPessoa: number | null
    IdReserva: number | null
  }

  export type PessoaReservaCountAggregateOutputType = {
    Id: number
    IdPessoa: number
    IdReserva: number
    _all: number
  }


  export type PessoaReservaAvgAggregateInputType = {
    Id?: true
    IdPessoa?: true
    IdReserva?: true
  }

  export type PessoaReservaSumAggregateInputType = {
    Id?: true
    IdPessoa?: true
    IdReserva?: true
  }

  export type PessoaReservaMinAggregateInputType = {
    Id?: true
    IdPessoa?: true
    IdReserva?: true
  }

  export type PessoaReservaMaxAggregateInputType = {
    Id?: true
    IdPessoa?: true
    IdReserva?: true
  }

  export type PessoaReservaCountAggregateInputType = {
    Id?: true
    IdPessoa?: true
    IdReserva?: true
    _all?: true
  }

  export type PessoaReservaAggregateArgs = {
    /**
     * Filter which PessoaReserva to aggregate.
     */
    where?: PessoaReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaReservas to fetch.
     */
    orderBy?: Enumerable<PessoaReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PessoaReservas
    **/
    _count?: true | PessoaReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaReservaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaReservaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaReservaMaxAggregateInputType
  }

  export type GetPessoaReservaAggregateType<T extends PessoaReservaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaReserva[P]>
      : GetScalarType<T[P], AggregatePessoaReserva[P]>
  }




  export type PessoaReservaGroupByArgs = {
    where?: PessoaReservaWhereInput
    orderBy?: Enumerable<PessoaReservaOrderByWithAggregationInput>
    by: PessoaReservaScalarFieldEnum[]
    having?: PessoaReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaReservaCountAggregateInputType | true
    _avg?: PessoaReservaAvgAggregateInputType
    _sum?: PessoaReservaSumAggregateInputType
    _min?: PessoaReservaMinAggregateInputType
    _max?: PessoaReservaMaxAggregateInputType
  }


  export type PessoaReservaGroupByOutputType = {
    Id: number
    IdPessoa: number
    IdReserva: number
    _count: PessoaReservaCountAggregateOutputType | null
    _avg: PessoaReservaAvgAggregateOutputType | null
    _sum: PessoaReservaSumAggregateOutputType | null
    _min: PessoaReservaMinAggregateOutputType | null
    _max: PessoaReservaMaxAggregateOutputType | null
  }

  type GetPessoaReservaGroupByPayload<T extends PessoaReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PessoaReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaReservaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaReservaGroupByOutputType[P]>
        }
      >
    >


  export type PessoaReservaSelect = {
    Id?: boolean
    Pessoa?: boolean | PessoaArgs
    IdPessoa?: boolean
    Reserva?: boolean | ReservaArgs
    IdReserva?: boolean
  }


  export type PessoaReservaInclude = {
    Pessoa?: boolean | PessoaArgs
    Reserva?: boolean | ReservaArgs
  }

  export type PessoaReservaGetPayload<S extends boolean | null | undefined | PessoaReservaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PessoaReserva :
    S extends undefined ? never :
    S extends { include: any } & (PessoaReservaArgs | PessoaReservaFindManyArgs)
    ? PessoaReserva  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Pessoa' ? PessoaGetPayload<S['include'][P]> :
        P extends 'Reserva' ? ReservaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PessoaReservaArgs | PessoaReservaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Pessoa' ? PessoaGetPayload<S['select'][P]> :
        P extends 'Reserva' ? ReservaGetPayload<S['select'][P]> :  P extends keyof PessoaReserva ? PessoaReserva[P] : never
  } 
      : PessoaReserva


  type PessoaReservaCountArgs = 
    Omit<PessoaReservaFindManyArgs, 'select' | 'include'> & {
      select?: PessoaReservaCountAggregateInputType | true
    }

  export interface PessoaReservaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PessoaReserva that matches the filter.
     * @param {PessoaReservaFindUniqueArgs} args - Arguments to find a PessoaReserva
     * @example
     * // Get one PessoaReserva
     * const pessoaReserva = await prisma.pessoaReserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PessoaReservaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PessoaReservaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PessoaReserva'> extends True ? Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>> : Prisma__PessoaReservaClient<PessoaReservaGetPayload<T> | null, null>

    /**
     * Find one PessoaReserva that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PessoaReservaFindUniqueOrThrowArgs} args - Arguments to find a PessoaReserva
     * @example
     * // Get one PessoaReserva
     * const pessoaReserva = await prisma.pessoaReserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PessoaReservaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PessoaReservaFindUniqueOrThrowArgs>
    ): Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>>

    /**
     * Find the first PessoaReserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaFindFirstArgs} args - Arguments to find a PessoaReserva
     * @example
     * // Get one PessoaReserva
     * const pessoaReserva = await prisma.pessoaReserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PessoaReservaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PessoaReservaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PessoaReserva'> extends True ? Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>> : Prisma__PessoaReservaClient<PessoaReservaGetPayload<T> | null, null>

    /**
     * Find the first PessoaReserva that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaFindFirstOrThrowArgs} args - Arguments to find a PessoaReserva
     * @example
     * // Get one PessoaReserva
     * const pessoaReserva = await prisma.pessoaReserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PessoaReservaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PessoaReservaFindFirstOrThrowArgs>
    ): Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>>

    /**
     * Find zero or more PessoaReservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaReservas
     * const pessoaReservas = await prisma.pessoaReserva.findMany()
     * 
     * // Get first 10 PessoaReservas
     * const pessoaReservas = await prisma.pessoaReserva.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const pessoaReservaWithIdOnly = await prisma.pessoaReserva.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends PessoaReservaFindManyArgs>(
      args?: SelectSubset<T, PessoaReservaFindManyArgs>
    ): Prisma.PrismaPromise<Array<PessoaReservaGetPayload<T>>>

    /**
     * Create a PessoaReserva.
     * @param {PessoaReservaCreateArgs} args - Arguments to create a PessoaReserva.
     * @example
     * // Create one PessoaReserva
     * const PessoaReserva = await prisma.pessoaReserva.create({
     *   data: {
     *     // ... data to create a PessoaReserva
     *   }
     * })
     * 
    **/
    create<T extends PessoaReservaCreateArgs>(
      args: SelectSubset<T, PessoaReservaCreateArgs>
    ): Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>>

    /**
     * Create many PessoaReservas.
     *     @param {PessoaReservaCreateManyArgs} args - Arguments to create many PessoaReservas.
     *     @example
     *     // Create many PessoaReservas
     *     const pessoaReserva = await prisma.pessoaReserva.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PessoaReservaCreateManyArgs>(
      args?: SelectSubset<T, PessoaReservaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PessoaReserva.
     * @param {PessoaReservaDeleteArgs} args - Arguments to delete one PessoaReserva.
     * @example
     * // Delete one PessoaReserva
     * const PessoaReserva = await prisma.pessoaReserva.delete({
     *   where: {
     *     // ... filter to delete one PessoaReserva
     *   }
     * })
     * 
    **/
    delete<T extends PessoaReservaDeleteArgs>(
      args: SelectSubset<T, PessoaReservaDeleteArgs>
    ): Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>>

    /**
     * Update one PessoaReserva.
     * @param {PessoaReservaUpdateArgs} args - Arguments to update one PessoaReserva.
     * @example
     * // Update one PessoaReserva
     * const pessoaReserva = await prisma.pessoaReserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PessoaReservaUpdateArgs>(
      args: SelectSubset<T, PessoaReservaUpdateArgs>
    ): Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>>

    /**
     * Delete zero or more PessoaReservas.
     * @param {PessoaReservaDeleteManyArgs} args - Arguments to filter PessoaReservas to delete.
     * @example
     * // Delete a few PessoaReservas
     * const { count } = await prisma.pessoaReserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PessoaReservaDeleteManyArgs>(
      args?: SelectSubset<T, PessoaReservaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaReservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaReservas
     * const pessoaReserva = await prisma.pessoaReserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PessoaReservaUpdateManyArgs>(
      args: SelectSubset<T, PessoaReservaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PessoaReserva.
     * @param {PessoaReservaUpsertArgs} args - Arguments to update or create a PessoaReserva.
     * @example
     * // Update or create a PessoaReserva
     * const pessoaReserva = await prisma.pessoaReserva.upsert({
     *   create: {
     *     // ... data to create a PessoaReserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaReserva we want to update
     *   }
     * })
    **/
    upsert<T extends PessoaReservaUpsertArgs>(
      args: SelectSubset<T, PessoaReservaUpsertArgs>
    ): Prisma__PessoaReservaClient<PessoaReservaGetPayload<T>>

    /**
     * Count the number of PessoaReservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaCountArgs} args - Arguments to filter PessoaReservas to count.
     * @example
     * // Count the number of PessoaReservas
     * const count = await prisma.pessoaReserva.count({
     *   where: {
     *     // ... the filter for the PessoaReservas we want to count
     *   }
     * })
    **/
    count<T extends PessoaReservaCountArgs>(
      args?: Subset<T, PessoaReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaReserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaReservaAggregateArgs>(args: Subset<T, PessoaReservaAggregateArgs>): Prisma.PrismaPromise<GetPessoaReservaAggregateType<T>>

    /**
     * Group by PessoaReserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaReservaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PessoaReserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PessoaReservaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    Reserva<T extends ReservaArgs= {}>(args?: Subset<T, ReservaArgs>): Prisma__ReservaClient<ReservaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PessoaReserva base type for findUnique actions
   */
  export type PessoaReservaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * Filter, which PessoaReserva to fetch.
     */
    where: PessoaReservaWhereUniqueInput
  }

  /**
   * PessoaReserva findUnique
   */
  export interface PessoaReservaFindUniqueArgs extends PessoaReservaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PessoaReserva findUniqueOrThrow
   */
  export type PessoaReservaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * Filter, which PessoaReserva to fetch.
     */
    where: PessoaReservaWhereUniqueInput
  }


  /**
   * PessoaReserva base type for findFirst actions
   */
  export type PessoaReservaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * Filter, which PessoaReserva to fetch.
     */
    where?: PessoaReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaReservas to fetch.
     */
    orderBy?: Enumerable<PessoaReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PessoaReservas.
     */
    cursor?: PessoaReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PessoaReservas.
     */
    distinct?: Enumerable<PessoaReservaScalarFieldEnum>
  }

  /**
   * PessoaReserva findFirst
   */
  export interface PessoaReservaFindFirstArgs extends PessoaReservaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PessoaReserva findFirstOrThrow
   */
  export type PessoaReservaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * Filter, which PessoaReserva to fetch.
     */
    where?: PessoaReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaReservas to fetch.
     */
    orderBy?: Enumerable<PessoaReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PessoaReservas.
     */
    cursor?: PessoaReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PessoaReservas.
     */
    distinct?: Enumerable<PessoaReservaScalarFieldEnum>
  }


  /**
   * PessoaReserva findMany
   */
  export type PessoaReservaFindManyArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * Filter, which PessoaReservas to fetch.
     */
    where?: PessoaReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaReservas to fetch.
     */
    orderBy?: Enumerable<PessoaReservaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PessoaReservas.
     */
    cursor?: PessoaReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaReservas.
     */
    skip?: number
    distinct?: Enumerable<PessoaReservaScalarFieldEnum>
  }


  /**
   * PessoaReserva create
   */
  export type PessoaReservaCreateArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * The data needed to create a PessoaReserva.
     */
    data: XOR<PessoaReservaCreateInput, PessoaReservaUncheckedCreateInput>
  }


  /**
   * PessoaReserva createMany
   */
  export type PessoaReservaCreateManyArgs = {
    /**
     * The data used to create many PessoaReservas.
     */
    data: Enumerable<PessoaReservaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PessoaReserva update
   */
  export type PessoaReservaUpdateArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * The data needed to update a PessoaReserva.
     */
    data: XOR<PessoaReservaUpdateInput, PessoaReservaUncheckedUpdateInput>
    /**
     * Choose, which PessoaReserva to update.
     */
    where: PessoaReservaWhereUniqueInput
  }


  /**
   * PessoaReserva updateMany
   */
  export type PessoaReservaUpdateManyArgs = {
    /**
     * The data used to update PessoaReservas.
     */
    data: XOR<PessoaReservaUpdateManyMutationInput, PessoaReservaUncheckedUpdateManyInput>
    /**
     * Filter which PessoaReservas to update
     */
    where?: PessoaReservaWhereInput
  }


  /**
   * PessoaReserva upsert
   */
  export type PessoaReservaUpsertArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * The filter to search for the PessoaReserva to update in case it exists.
     */
    where: PessoaReservaWhereUniqueInput
    /**
     * In case the PessoaReserva found by the `where` argument doesn't exist, create a new PessoaReserva with this data.
     */
    create: XOR<PessoaReservaCreateInput, PessoaReservaUncheckedCreateInput>
    /**
     * In case the PessoaReserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaReservaUpdateInput, PessoaReservaUncheckedUpdateInput>
  }


  /**
   * PessoaReserva delete
   */
  export type PessoaReservaDeleteArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
    /**
     * Filter which PessoaReserva to delete.
     */
    where: PessoaReservaWhereUniqueInput
  }


  /**
   * PessoaReserva deleteMany
   */
  export type PessoaReservaDeleteManyArgs = {
    /**
     * Filter which PessoaReservas to delete
     */
    where?: PessoaReservaWhereInput
  }


  /**
   * PessoaReserva without action
   */
  export type PessoaReservaArgs = {
    /**
     * Select specific fields to fetch from the PessoaReserva
     */
    select?: PessoaReservaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaReservaInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const PessoaReservaScalarFieldEnum: {
    Id: 'Id',
    IdPessoa: 'IdPessoa',
    IdReserva: 'IdReserva'
  };

  export type PessoaReservaScalarFieldEnum = (typeof PessoaReservaScalarFieldEnum)[keyof typeof PessoaReservaScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    Id: 'Id',
    Nome: 'Nome',
    Apelido: 'Apelido',
    Celular: 'Celular'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const ReservaScalarFieldEnum: {
    Id: 'Id',
    IdVeiculo: 'IdVeiculo',
    QtdeLugaresOcupados: 'QtdeLugaresOcupados',
    DataHoraSaida: 'DataHoraSaida',
    DataReserva: 'DataReserva',
    DataHoraChegadaPrevista: 'DataHoraChegadaPrevista',
    Tolerancia: 'Tolerancia'
  };

  export type ReservaScalarFieldEnum = (typeof ReservaScalarFieldEnum)[keyof typeof ReservaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TipoVeiculoScalarFieldEnum: {
    Id: 'Id',
    Descricao: 'Descricao',
    QtdeLugares: 'QtdeLugares'
  };

  export type TipoVeiculoScalarFieldEnum = (typeof TipoVeiculoScalarFieldEnum)[keyof typeof TipoVeiculoScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VeiculoScalarFieldEnum: {
    Id: 'Id',
    IdTipoVeiculo: 'IdTipoVeiculo',
    IdMotorista: 'IdMotorista',
    Apelido: 'Apelido'
  };

  export type VeiculoScalarFieldEnum = (typeof VeiculoScalarFieldEnum)[keyof typeof VeiculoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type TipoVeiculoWhereInput = {
    AND?: Enumerable<TipoVeiculoWhereInput>
    OR?: Enumerable<TipoVeiculoWhereInput>
    NOT?: Enumerable<TipoVeiculoWhereInput>
    Id?: IntFilter | number
    Descricao?: StringFilter | string
    QtdeLugares?: IntFilter | number
    veiculos?: VeiculoListRelationFilter
  }

  export type TipoVeiculoOrderByWithRelationInput = {
    Id?: SortOrder
    Descricao?: SortOrder
    QtdeLugares?: SortOrder
    veiculos?: VeiculoOrderByRelationAggregateInput
  }

  export type TipoVeiculoWhereUniqueInput = {
    Id?: number
  }

  export type TipoVeiculoOrderByWithAggregationInput = {
    Id?: SortOrder
    Descricao?: SortOrder
    QtdeLugares?: SortOrder
    _count?: TipoVeiculoCountOrderByAggregateInput
    _avg?: TipoVeiculoAvgOrderByAggregateInput
    _max?: TipoVeiculoMaxOrderByAggregateInput
    _min?: TipoVeiculoMinOrderByAggregateInput
    _sum?: TipoVeiculoSumOrderByAggregateInput
  }

  export type TipoVeiculoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoVeiculoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoVeiculoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoVeiculoScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Descricao?: StringWithAggregatesFilter | string
    QtdeLugares?: IntWithAggregatesFilter | number
  }

  export type PessoaWhereInput = {
    AND?: Enumerable<PessoaWhereInput>
    OR?: Enumerable<PessoaWhereInput>
    NOT?: Enumerable<PessoaWhereInput>
    Id?: IntFilter | number
    Nome?: StringFilter | string
    Apelido?: StringFilter | string
    Celular?: StringFilter | string
    Veiculo?: VeiculoListRelationFilter
    PessoaReserva?: PessoaReservaListRelationFilter
  }

  export type PessoaOrderByWithRelationInput = {
    Id?: SortOrder
    Nome?: SortOrder
    Apelido?: SortOrder
    Celular?: SortOrder
    Veiculo?: VeiculoOrderByRelationAggregateInput
    PessoaReserva?: PessoaReservaOrderByRelationAggregateInput
  }

  export type PessoaWhereUniqueInput = {
    Id?: number
  }

  export type PessoaOrderByWithAggregationInput = {
    Id?: SortOrder
    Nome?: SortOrder
    Apelido?: SortOrder
    Celular?: SortOrder
    _count?: PessoaCountOrderByAggregateInput
    _avg?: PessoaAvgOrderByAggregateInput
    _max?: PessoaMaxOrderByAggregateInput
    _min?: PessoaMinOrderByAggregateInput
    _sum?: PessoaSumOrderByAggregateInput
  }

  export type PessoaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PessoaScalarWhereWithAggregatesInput>
    OR?: Enumerable<PessoaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PessoaScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Nome?: StringWithAggregatesFilter | string
    Apelido?: StringWithAggregatesFilter | string
    Celular?: StringWithAggregatesFilter | string
  }

  export type VeiculoWhereInput = {
    AND?: Enumerable<VeiculoWhereInput>
    OR?: Enumerable<VeiculoWhereInput>
    NOT?: Enumerable<VeiculoWhereInput>
    Id?: IntFilter | number
    TipoVeiculo?: XOR<TipoVeiculoRelationFilter, TipoVeiculoWhereInput>
    IdTipoVeiculo?: IntFilter | number
    Motorista?: XOR<PessoaRelationFilter, PessoaWhereInput>
    IdMotorista?: IntFilter | number
    Apelido?: StringFilter | string
    Reserva?: ReservaListRelationFilter
  }

  export type VeiculoOrderByWithRelationInput = {
    Id?: SortOrder
    TipoVeiculo?: TipoVeiculoOrderByWithRelationInput
    IdTipoVeiculo?: SortOrder
    Motorista?: PessoaOrderByWithRelationInput
    IdMotorista?: SortOrder
    Apelido?: SortOrder
    Reserva?: ReservaOrderByRelationAggregateInput
  }

  export type VeiculoWhereUniqueInput = {
    Id?: number
  }

  export type VeiculoOrderByWithAggregationInput = {
    Id?: SortOrder
    IdTipoVeiculo?: SortOrder
    IdMotorista?: SortOrder
    Apelido?: SortOrder
    _count?: VeiculoCountOrderByAggregateInput
    _avg?: VeiculoAvgOrderByAggregateInput
    _max?: VeiculoMaxOrderByAggregateInput
    _min?: VeiculoMinOrderByAggregateInput
    _sum?: VeiculoSumOrderByAggregateInput
  }

  export type VeiculoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VeiculoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VeiculoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VeiculoScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    IdTipoVeiculo?: IntWithAggregatesFilter | number
    IdMotorista?: IntWithAggregatesFilter | number
    Apelido?: StringWithAggregatesFilter | string
  }

  export type ReservaWhereInput = {
    AND?: Enumerable<ReservaWhereInput>
    OR?: Enumerable<ReservaWhereInput>
    NOT?: Enumerable<ReservaWhereInput>
    Id?: IntFilter | number
    Veiculo?: XOR<VeiculoRelationFilter, VeiculoWhereInput>
    IdVeiculo?: IntFilter | number
    QtdeLugaresOcupados?: IntFilter | number
    DataHoraSaida?: DateTimeFilter | Date | string
    DataReserva?: DateTimeFilter | Date | string
    DataHoraChegadaPrevista?: DateTimeFilter | Date | string
    Tolerancia?: FloatFilter | number
    PessoaReserva?: PessoaReservaListRelationFilter
  }

  export type ReservaOrderByWithRelationInput = {
    Id?: SortOrder
    Veiculo?: VeiculoOrderByWithRelationInput
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    DataHoraSaida?: SortOrder
    DataReserva?: SortOrder
    DataHoraChegadaPrevista?: SortOrder
    Tolerancia?: SortOrder
    PessoaReserva?: PessoaReservaOrderByRelationAggregateInput
  }

  export type ReservaWhereUniqueInput = {
    Id?: number
  }

  export type ReservaOrderByWithAggregationInput = {
    Id?: SortOrder
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    DataHoraSaida?: SortOrder
    DataReserva?: SortOrder
    DataHoraChegadaPrevista?: SortOrder
    Tolerancia?: SortOrder
    _count?: ReservaCountOrderByAggregateInput
    _avg?: ReservaAvgOrderByAggregateInput
    _max?: ReservaMaxOrderByAggregateInput
    _min?: ReservaMinOrderByAggregateInput
    _sum?: ReservaSumOrderByAggregateInput
  }

  export type ReservaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReservaScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReservaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReservaScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    IdVeiculo?: IntWithAggregatesFilter | number
    QtdeLugaresOcupados?: IntWithAggregatesFilter | number
    DataHoraSaida?: DateTimeWithAggregatesFilter | Date | string
    DataReserva?: DateTimeWithAggregatesFilter | Date | string
    DataHoraChegadaPrevista?: DateTimeWithAggregatesFilter | Date | string
    Tolerancia?: FloatWithAggregatesFilter | number
  }

  export type PessoaReservaWhereInput = {
    AND?: Enumerable<PessoaReservaWhereInput>
    OR?: Enumerable<PessoaReservaWhereInput>
    NOT?: Enumerable<PessoaReservaWhereInput>
    Id?: IntFilter | number
    Pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput>
    IdPessoa?: IntFilter | number
    Reserva?: XOR<ReservaRelationFilter, ReservaWhereInput>
    IdReserva?: IntFilter | number
  }

  export type PessoaReservaOrderByWithRelationInput = {
    Id?: SortOrder
    Pessoa?: PessoaOrderByWithRelationInput
    IdPessoa?: SortOrder
    Reserva?: ReservaOrderByWithRelationInput
    IdReserva?: SortOrder
  }

  export type PessoaReservaWhereUniqueInput = {
    Id?: number
  }

  export type PessoaReservaOrderByWithAggregationInput = {
    Id?: SortOrder
    IdPessoa?: SortOrder
    IdReserva?: SortOrder
    _count?: PessoaReservaCountOrderByAggregateInput
    _avg?: PessoaReservaAvgOrderByAggregateInput
    _max?: PessoaReservaMaxOrderByAggregateInput
    _min?: PessoaReservaMinOrderByAggregateInput
    _sum?: PessoaReservaSumOrderByAggregateInput
  }

  export type PessoaReservaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PessoaReservaScalarWhereWithAggregatesInput>
    OR?: Enumerable<PessoaReservaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PessoaReservaScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    IdPessoa?: IntWithAggregatesFilter | number
    IdReserva?: IntWithAggregatesFilter | number
  }

  export type TipoVeiculoCreateInput = {
    Descricao: string
    QtdeLugares: number
    veiculos?: VeiculoCreateNestedManyWithoutTipoVeiculoInput
  }

  export type TipoVeiculoUncheckedCreateInput = {
    Id?: number
    Descricao: string
    QtdeLugares: number
    veiculos?: VeiculoUncheckedCreateNestedManyWithoutTipoVeiculoInput
  }

  export type TipoVeiculoUpdateInput = {
    Descricao?: StringFieldUpdateOperationsInput | string
    QtdeLugares?: IntFieldUpdateOperationsInput | number
    veiculos?: VeiculoUpdateManyWithoutTipoVeiculoNestedInput
  }

  export type TipoVeiculoUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Descricao?: StringFieldUpdateOperationsInput | string
    QtdeLugares?: IntFieldUpdateOperationsInput | number
    veiculos?: VeiculoUncheckedUpdateManyWithoutTipoVeiculoNestedInput
  }

  export type TipoVeiculoCreateManyInput = {
    Id?: number
    Descricao: string
    QtdeLugares: number
  }

  export type TipoVeiculoUpdateManyMutationInput = {
    Descricao?: StringFieldUpdateOperationsInput | string
    QtdeLugares?: IntFieldUpdateOperationsInput | number
  }

  export type TipoVeiculoUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Descricao?: StringFieldUpdateOperationsInput | string
    QtdeLugares?: IntFieldUpdateOperationsInput | number
  }

  export type PessoaCreateInput = {
    Nome: string
    Apelido: string
    Celular: string
    Veiculo?: VeiculoCreateNestedManyWithoutMotoristaInput
    PessoaReserva?: PessoaReservaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateInput = {
    Id?: number
    Nome: string
    Apelido: string
    Celular: string
    Veiculo?: VeiculoUncheckedCreateNestedManyWithoutMotoristaInput
    PessoaReserva?: PessoaReservaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUpdateInput = {
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
    Veiculo?: VeiculoUpdateManyWithoutMotoristaNestedInput
    PessoaReserva?: PessoaReservaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
    Veiculo?: VeiculoUncheckedUpdateManyWithoutMotoristaNestedInput
    PessoaReserva?: PessoaReservaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaCreateManyInput = {
    Id?: number
    Nome: string
    Apelido: string
    Celular: string
  }

  export type PessoaUpdateManyMutationInput = {
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
  }

  export type VeiculoCreateInput = {
    TipoVeiculo: TipoVeiculoCreateNestedOneWithoutVeiculosInput
    Motorista: PessoaCreateNestedOneWithoutVeiculoInput
    Apelido: string
    Reserva?: ReservaCreateNestedManyWithoutVeiculoInput
  }

  export type VeiculoUncheckedCreateInput = {
    Id?: number
    IdTipoVeiculo: number
    IdMotorista: number
    Apelido: string
    Reserva?: ReservaUncheckedCreateNestedManyWithoutVeiculoInput
  }

  export type VeiculoUpdateInput = {
    TipoVeiculo?: TipoVeiculoUpdateOneRequiredWithoutVeiculosNestedInput
    Motorista?: PessoaUpdateOneRequiredWithoutVeiculoNestedInput
    Apelido?: StringFieldUpdateOperationsInput | string
    Reserva?: ReservaUpdateManyWithoutVeiculoNestedInput
  }

  export type VeiculoUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdTipoVeiculo?: IntFieldUpdateOperationsInput | number
    IdMotorista?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
    Reserva?: ReservaUncheckedUpdateManyWithoutVeiculoNestedInput
  }

  export type VeiculoCreateManyInput = {
    Id?: number
    IdTipoVeiculo: number
    IdMotorista: number
    Apelido: string
  }

  export type VeiculoUpdateManyMutationInput = {
    Apelido?: StringFieldUpdateOperationsInput | string
  }

  export type VeiculoUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdTipoVeiculo?: IntFieldUpdateOperationsInput | number
    IdMotorista?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
  }

  export type ReservaCreateInput = {
    Veiculo: VeiculoCreateNestedOneWithoutReservaInput
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
    PessoaReserva?: PessoaReservaCreateNestedManyWithoutReservaInput
  }

  export type ReservaUncheckedCreateInput = {
    Id?: number
    IdVeiculo: number
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
    PessoaReserva?: PessoaReservaUncheckedCreateNestedManyWithoutReservaInput
  }

  export type ReservaUpdateInput = {
    Veiculo?: VeiculoUpdateOneRequiredWithoutReservaNestedInput
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
    PessoaReserva?: PessoaReservaUpdateManyWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdVeiculo?: IntFieldUpdateOperationsInput | number
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
    PessoaReserva?: PessoaReservaUncheckedUpdateManyWithoutReservaNestedInput
  }

  export type ReservaCreateManyInput = {
    Id?: number
    IdVeiculo: number
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
  }

  export type ReservaUpdateManyMutationInput = {
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
  }

  export type ReservaUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdVeiculo?: IntFieldUpdateOperationsInput | number
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
  }

  export type PessoaReservaCreateInput = {
    Pessoa: PessoaCreateNestedOneWithoutPessoaReservaInput
    Reserva: ReservaCreateNestedOneWithoutPessoaReservaInput
  }

  export type PessoaReservaUncheckedCreateInput = {
    Id?: number
    IdPessoa: number
    IdReserva: number
  }

  export type PessoaReservaUpdateInput = {
    Pessoa?: PessoaUpdateOneRequiredWithoutPessoaReservaNestedInput
    Reserva?: ReservaUpdateOneRequiredWithoutPessoaReservaNestedInput
  }

  export type PessoaReservaUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdPessoa?: IntFieldUpdateOperationsInput | number
    IdReserva?: IntFieldUpdateOperationsInput | number
  }

  export type PessoaReservaCreateManyInput = {
    Id?: number
    IdPessoa: number
    IdReserva: number
  }

  export type PessoaReservaUpdateManyMutationInput = {

  }

  export type PessoaReservaUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdPessoa?: IntFieldUpdateOperationsInput | number
    IdReserva?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type VeiculoListRelationFilter = {
    every?: VeiculoWhereInput
    some?: VeiculoWhereInput
    none?: VeiculoWhereInput
  }

  export type VeiculoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoVeiculoCountOrderByAggregateInput = {
    Id?: SortOrder
    Descricao?: SortOrder
    QtdeLugares?: SortOrder
  }

  export type TipoVeiculoAvgOrderByAggregateInput = {
    Id?: SortOrder
    QtdeLugares?: SortOrder
  }

  export type TipoVeiculoMaxOrderByAggregateInput = {
    Id?: SortOrder
    Descricao?: SortOrder
    QtdeLugares?: SortOrder
  }

  export type TipoVeiculoMinOrderByAggregateInput = {
    Id?: SortOrder
    Descricao?: SortOrder
    QtdeLugares?: SortOrder
  }

  export type TipoVeiculoSumOrderByAggregateInput = {
    Id?: SortOrder
    QtdeLugares?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type PessoaReservaListRelationFilter = {
    every?: PessoaReservaWhereInput
    some?: PessoaReservaWhereInput
    none?: PessoaReservaWhereInput
  }

  export type PessoaReservaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PessoaCountOrderByAggregateInput = {
    Id?: SortOrder
    Nome?: SortOrder
    Apelido?: SortOrder
    Celular?: SortOrder
  }

  export type PessoaAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type PessoaMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nome?: SortOrder
    Apelido?: SortOrder
    Celular?: SortOrder
  }

  export type PessoaMinOrderByAggregateInput = {
    Id?: SortOrder
    Nome?: SortOrder
    Apelido?: SortOrder
    Celular?: SortOrder
  }

  export type PessoaSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type TipoVeiculoRelationFilter = {
    is?: TipoVeiculoWhereInput
    isNot?: TipoVeiculoWhereInput
  }

  export type PessoaRelationFilter = {
    is?: PessoaWhereInput
    isNot?: PessoaWhereInput
  }

  export type ReservaListRelationFilter = {
    every?: ReservaWhereInput
    some?: ReservaWhereInput
    none?: ReservaWhereInput
  }

  export type ReservaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VeiculoCountOrderByAggregateInput = {
    Id?: SortOrder
    IdTipoVeiculo?: SortOrder
    IdMotorista?: SortOrder
    Apelido?: SortOrder
  }

  export type VeiculoAvgOrderByAggregateInput = {
    Id?: SortOrder
    IdTipoVeiculo?: SortOrder
    IdMotorista?: SortOrder
  }

  export type VeiculoMaxOrderByAggregateInput = {
    Id?: SortOrder
    IdTipoVeiculo?: SortOrder
    IdMotorista?: SortOrder
    Apelido?: SortOrder
  }

  export type VeiculoMinOrderByAggregateInput = {
    Id?: SortOrder
    IdTipoVeiculo?: SortOrder
    IdMotorista?: SortOrder
    Apelido?: SortOrder
  }

  export type VeiculoSumOrderByAggregateInput = {
    Id?: SortOrder
    IdTipoVeiculo?: SortOrder
    IdMotorista?: SortOrder
  }

  export type VeiculoRelationFilter = {
    is?: VeiculoWhereInput
    isNot?: VeiculoWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type ReservaCountOrderByAggregateInput = {
    Id?: SortOrder
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    DataHoraSaida?: SortOrder
    DataReserva?: SortOrder
    DataHoraChegadaPrevista?: SortOrder
    Tolerancia?: SortOrder
  }

  export type ReservaAvgOrderByAggregateInput = {
    Id?: SortOrder
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    Tolerancia?: SortOrder
  }

  export type ReservaMaxOrderByAggregateInput = {
    Id?: SortOrder
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    DataHoraSaida?: SortOrder
    DataReserva?: SortOrder
    DataHoraChegadaPrevista?: SortOrder
    Tolerancia?: SortOrder
  }

  export type ReservaMinOrderByAggregateInput = {
    Id?: SortOrder
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    DataHoraSaida?: SortOrder
    DataReserva?: SortOrder
    DataHoraChegadaPrevista?: SortOrder
    Tolerancia?: SortOrder
  }

  export type ReservaSumOrderByAggregateInput = {
    Id?: SortOrder
    IdVeiculo?: SortOrder
    QtdeLugaresOcupados?: SortOrder
    Tolerancia?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type ReservaRelationFilter = {
    is?: ReservaWhereInput
    isNot?: ReservaWhereInput
  }

  export type PessoaReservaCountOrderByAggregateInput = {
    Id?: SortOrder
    IdPessoa?: SortOrder
    IdReserva?: SortOrder
  }

  export type PessoaReservaAvgOrderByAggregateInput = {
    Id?: SortOrder
    IdPessoa?: SortOrder
    IdReserva?: SortOrder
  }

  export type PessoaReservaMaxOrderByAggregateInput = {
    Id?: SortOrder
    IdPessoa?: SortOrder
    IdReserva?: SortOrder
  }

  export type PessoaReservaMinOrderByAggregateInput = {
    Id?: SortOrder
    IdPessoa?: SortOrder
    IdReserva?: SortOrder
  }

  export type PessoaReservaSumOrderByAggregateInput = {
    Id?: SortOrder
    IdPessoa?: SortOrder
    IdReserva?: SortOrder
  }

  export type VeiculoCreateNestedManyWithoutTipoVeiculoInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutTipoVeiculoInput>, Enumerable<VeiculoUncheckedCreateWithoutTipoVeiculoInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutTipoVeiculoInput>
    createMany?: VeiculoCreateManyTipoVeiculoInputEnvelope
    connect?: Enumerable<VeiculoWhereUniqueInput>
  }

  export type VeiculoUncheckedCreateNestedManyWithoutTipoVeiculoInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutTipoVeiculoInput>, Enumerable<VeiculoUncheckedCreateWithoutTipoVeiculoInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutTipoVeiculoInput>
    createMany?: VeiculoCreateManyTipoVeiculoInputEnvelope
    connect?: Enumerable<VeiculoWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VeiculoUpdateManyWithoutTipoVeiculoNestedInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutTipoVeiculoInput>, Enumerable<VeiculoUncheckedCreateWithoutTipoVeiculoInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutTipoVeiculoInput>
    upsert?: Enumerable<VeiculoUpsertWithWhereUniqueWithoutTipoVeiculoInput>
    createMany?: VeiculoCreateManyTipoVeiculoInputEnvelope
    set?: Enumerable<VeiculoWhereUniqueInput>
    disconnect?: Enumerable<VeiculoWhereUniqueInput>
    delete?: Enumerable<VeiculoWhereUniqueInput>
    connect?: Enumerable<VeiculoWhereUniqueInput>
    update?: Enumerable<VeiculoUpdateWithWhereUniqueWithoutTipoVeiculoInput>
    updateMany?: Enumerable<VeiculoUpdateManyWithWhereWithoutTipoVeiculoInput>
    deleteMany?: Enumerable<VeiculoScalarWhereInput>
  }

  export type VeiculoUncheckedUpdateManyWithoutTipoVeiculoNestedInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutTipoVeiculoInput>, Enumerable<VeiculoUncheckedCreateWithoutTipoVeiculoInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutTipoVeiculoInput>
    upsert?: Enumerable<VeiculoUpsertWithWhereUniqueWithoutTipoVeiculoInput>
    createMany?: VeiculoCreateManyTipoVeiculoInputEnvelope
    set?: Enumerable<VeiculoWhereUniqueInput>
    disconnect?: Enumerable<VeiculoWhereUniqueInput>
    delete?: Enumerable<VeiculoWhereUniqueInput>
    connect?: Enumerable<VeiculoWhereUniqueInput>
    update?: Enumerable<VeiculoUpdateWithWhereUniqueWithoutTipoVeiculoInput>
    updateMany?: Enumerable<VeiculoUpdateManyWithWhereWithoutTipoVeiculoInput>
    deleteMany?: Enumerable<VeiculoScalarWhereInput>
  }

  export type VeiculoCreateNestedManyWithoutMotoristaInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutMotoristaInput>, Enumerable<VeiculoUncheckedCreateWithoutMotoristaInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutMotoristaInput>
    createMany?: VeiculoCreateManyMotoristaInputEnvelope
    connect?: Enumerable<VeiculoWhereUniqueInput>
  }

  export type PessoaReservaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutPessoaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutPessoaInput>
    createMany?: PessoaReservaCreateManyPessoaInputEnvelope
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
  }

  export type VeiculoUncheckedCreateNestedManyWithoutMotoristaInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutMotoristaInput>, Enumerable<VeiculoUncheckedCreateWithoutMotoristaInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutMotoristaInput>
    createMany?: VeiculoCreateManyMotoristaInputEnvelope
    connect?: Enumerable<VeiculoWhereUniqueInput>
  }

  export type PessoaReservaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutPessoaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutPessoaInput>
    createMany?: PessoaReservaCreateManyPessoaInputEnvelope
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
  }

  export type VeiculoUpdateManyWithoutMotoristaNestedInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutMotoristaInput>, Enumerable<VeiculoUncheckedCreateWithoutMotoristaInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutMotoristaInput>
    upsert?: Enumerable<VeiculoUpsertWithWhereUniqueWithoutMotoristaInput>
    createMany?: VeiculoCreateManyMotoristaInputEnvelope
    set?: Enumerable<VeiculoWhereUniqueInput>
    disconnect?: Enumerable<VeiculoWhereUniqueInput>
    delete?: Enumerable<VeiculoWhereUniqueInput>
    connect?: Enumerable<VeiculoWhereUniqueInput>
    update?: Enumerable<VeiculoUpdateWithWhereUniqueWithoutMotoristaInput>
    updateMany?: Enumerable<VeiculoUpdateManyWithWhereWithoutMotoristaInput>
    deleteMany?: Enumerable<VeiculoScalarWhereInput>
  }

  export type PessoaReservaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutPessoaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<PessoaReservaUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: PessoaReservaCreateManyPessoaInputEnvelope
    set?: Enumerable<PessoaReservaWhereUniqueInput>
    disconnect?: Enumerable<PessoaReservaWhereUniqueInput>
    delete?: Enumerable<PessoaReservaWhereUniqueInput>
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
    update?: Enumerable<PessoaReservaUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<PessoaReservaUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<PessoaReservaScalarWhereInput>
  }

  export type VeiculoUncheckedUpdateManyWithoutMotoristaNestedInput = {
    create?: XOR<Enumerable<VeiculoCreateWithoutMotoristaInput>, Enumerable<VeiculoUncheckedCreateWithoutMotoristaInput>>
    connectOrCreate?: Enumerable<VeiculoCreateOrConnectWithoutMotoristaInput>
    upsert?: Enumerable<VeiculoUpsertWithWhereUniqueWithoutMotoristaInput>
    createMany?: VeiculoCreateManyMotoristaInputEnvelope
    set?: Enumerable<VeiculoWhereUniqueInput>
    disconnect?: Enumerable<VeiculoWhereUniqueInput>
    delete?: Enumerable<VeiculoWhereUniqueInput>
    connect?: Enumerable<VeiculoWhereUniqueInput>
    update?: Enumerable<VeiculoUpdateWithWhereUniqueWithoutMotoristaInput>
    updateMany?: Enumerable<VeiculoUpdateManyWithWhereWithoutMotoristaInput>
    deleteMany?: Enumerable<VeiculoScalarWhereInput>
  }

  export type PessoaReservaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutPessoaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<PessoaReservaUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: PessoaReservaCreateManyPessoaInputEnvelope
    set?: Enumerable<PessoaReservaWhereUniqueInput>
    disconnect?: Enumerable<PessoaReservaWhereUniqueInput>
    delete?: Enumerable<PessoaReservaWhereUniqueInput>
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
    update?: Enumerable<PessoaReservaUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<PessoaReservaUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<PessoaReservaScalarWhereInput>
  }

  export type TipoVeiculoCreateNestedOneWithoutVeiculosInput = {
    create?: XOR<TipoVeiculoCreateWithoutVeiculosInput, TipoVeiculoUncheckedCreateWithoutVeiculosInput>
    connectOrCreate?: TipoVeiculoCreateOrConnectWithoutVeiculosInput
    connect?: TipoVeiculoWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutVeiculoInput = {
    create?: XOR<PessoaCreateWithoutVeiculoInput, PessoaUncheckedCreateWithoutVeiculoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutVeiculoInput
    connect?: PessoaWhereUniqueInput
  }

  export type ReservaCreateNestedManyWithoutVeiculoInput = {
    create?: XOR<Enumerable<ReservaCreateWithoutVeiculoInput>, Enumerable<ReservaUncheckedCreateWithoutVeiculoInput>>
    connectOrCreate?: Enumerable<ReservaCreateOrConnectWithoutVeiculoInput>
    createMany?: ReservaCreateManyVeiculoInputEnvelope
    connect?: Enumerable<ReservaWhereUniqueInput>
  }

  export type ReservaUncheckedCreateNestedManyWithoutVeiculoInput = {
    create?: XOR<Enumerable<ReservaCreateWithoutVeiculoInput>, Enumerable<ReservaUncheckedCreateWithoutVeiculoInput>>
    connectOrCreate?: Enumerable<ReservaCreateOrConnectWithoutVeiculoInput>
    createMany?: ReservaCreateManyVeiculoInputEnvelope
    connect?: Enumerable<ReservaWhereUniqueInput>
  }

  export type TipoVeiculoUpdateOneRequiredWithoutVeiculosNestedInput = {
    create?: XOR<TipoVeiculoCreateWithoutVeiculosInput, TipoVeiculoUncheckedCreateWithoutVeiculosInput>
    connectOrCreate?: TipoVeiculoCreateOrConnectWithoutVeiculosInput
    upsert?: TipoVeiculoUpsertWithoutVeiculosInput
    connect?: TipoVeiculoWhereUniqueInput
    update?: XOR<TipoVeiculoUpdateWithoutVeiculosInput, TipoVeiculoUncheckedUpdateWithoutVeiculosInput>
  }

  export type PessoaUpdateOneRequiredWithoutVeiculoNestedInput = {
    create?: XOR<PessoaCreateWithoutVeiculoInput, PessoaUncheckedCreateWithoutVeiculoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutVeiculoInput
    upsert?: PessoaUpsertWithoutVeiculoInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutVeiculoInput, PessoaUncheckedUpdateWithoutVeiculoInput>
  }

  export type ReservaUpdateManyWithoutVeiculoNestedInput = {
    create?: XOR<Enumerable<ReservaCreateWithoutVeiculoInput>, Enumerable<ReservaUncheckedCreateWithoutVeiculoInput>>
    connectOrCreate?: Enumerable<ReservaCreateOrConnectWithoutVeiculoInput>
    upsert?: Enumerable<ReservaUpsertWithWhereUniqueWithoutVeiculoInput>
    createMany?: ReservaCreateManyVeiculoInputEnvelope
    set?: Enumerable<ReservaWhereUniqueInput>
    disconnect?: Enumerable<ReservaWhereUniqueInput>
    delete?: Enumerable<ReservaWhereUniqueInput>
    connect?: Enumerable<ReservaWhereUniqueInput>
    update?: Enumerable<ReservaUpdateWithWhereUniqueWithoutVeiculoInput>
    updateMany?: Enumerable<ReservaUpdateManyWithWhereWithoutVeiculoInput>
    deleteMany?: Enumerable<ReservaScalarWhereInput>
  }

  export type ReservaUncheckedUpdateManyWithoutVeiculoNestedInput = {
    create?: XOR<Enumerable<ReservaCreateWithoutVeiculoInput>, Enumerable<ReservaUncheckedCreateWithoutVeiculoInput>>
    connectOrCreate?: Enumerable<ReservaCreateOrConnectWithoutVeiculoInput>
    upsert?: Enumerable<ReservaUpsertWithWhereUniqueWithoutVeiculoInput>
    createMany?: ReservaCreateManyVeiculoInputEnvelope
    set?: Enumerable<ReservaWhereUniqueInput>
    disconnect?: Enumerable<ReservaWhereUniqueInput>
    delete?: Enumerable<ReservaWhereUniqueInput>
    connect?: Enumerable<ReservaWhereUniqueInput>
    update?: Enumerable<ReservaUpdateWithWhereUniqueWithoutVeiculoInput>
    updateMany?: Enumerable<ReservaUpdateManyWithWhereWithoutVeiculoInput>
    deleteMany?: Enumerable<ReservaScalarWhereInput>
  }

  export type VeiculoCreateNestedOneWithoutReservaInput = {
    create?: XOR<VeiculoCreateWithoutReservaInput, VeiculoUncheckedCreateWithoutReservaInput>
    connectOrCreate?: VeiculoCreateOrConnectWithoutReservaInput
    connect?: VeiculoWhereUniqueInput
  }

  export type PessoaReservaCreateNestedManyWithoutReservaInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutReservaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutReservaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutReservaInput>
    createMany?: PessoaReservaCreateManyReservaInputEnvelope
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
  }

  export type PessoaReservaUncheckedCreateNestedManyWithoutReservaInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutReservaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutReservaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutReservaInput>
    createMany?: PessoaReservaCreateManyReservaInputEnvelope
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
  }

  export type VeiculoUpdateOneRequiredWithoutReservaNestedInput = {
    create?: XOR<VeiculoCreateWithoutReservaInput, VeiculoUncheckedCreateWithoutReservaInput>
    connectOrCreate?: VeiculoCreateOrConnectWithoutReservaInput
    upsert?: VeiculoUpsertWithoutReservaInput
    connect?: VeiculoWhereUniqueInput
    update?: XOR<VeiculoUpdateWithoutReservaInput, VeiculoUncheckedUpdateWithoutReservaInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PessoaReservaUpdateManyWithoutReservaNestedInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutReservaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutReservaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutReservaInput>
    upsert?: Enumerable<PessoaReservaUpsertWithWhereUniqueWithoutReservaInput>
    createMany?: PessoaReservaCreateManyReservaInputEnvelope
    set?: Enumerable<PessoaReservaWhereUniqueInput>
    disconnect?: Enumerable<PessoaReservaWhereUniqueInput>
    delete?: Enumerable<PessoaReservaWhereUniqueInput>
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
    update?: Enumerable<PessoaReservaUpdateWithWhereUniqueWithoutReservaInput>
    updateMany?: Enumerable<PessoaReservaUpdateManyWithWhereWithoutReservaInput>
    deleteMany?: Enumerable<PessoaReservaScalarWhereInput>
  }

  export type PessoaReservaUncheckedUpdateManyWithoutReservaNestedInput = {
    create?: XOR<Enumerable<PessoaReservaCreateWithoutReservaInput>, Enumerable<PessoaReservaUncheckedCreateWithoutReservaInput>>
    connectOrCreate?: Enumerable<PessoaReservaCreateOrConnectWithoutReservaInput>
    upsert?: Enumerable<PessoaReservaUpsertWithWhereUniqueWithoutReservaInput>
    createMany?: PessoaReservaCreateManyReservaInputEnvelope
    set?: Enumerable<PessoaReservaWhereUniqueInput>
    disconnect?: Enumerable<PessoaReservaWhereUniqueInput>
    delete?: Enumerable<PessoaReservaWhereUniqueInput>
    connect?: Enumerable<PessoaReservaWhereUniqueInput>
    update?: Enumerable<PessoaReservaUpdateWithWhereUniqueWithoutReservaInput>
    updateMany?: Enumerable<PessoaReservaUpdateManyWithWhereWithoutReservaInput>
    deleteMany?: Enumerable<PessoaReservaScalarWhereInput>
  }

  export type PessoaCreateNestedOneWithoutPessoaReservaInput = {
    create?: XOR<PessoaCreateWithoutPessoaReservaInput, PessoaUncheckedCreateWithoutPessoaReservaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaReservaInput
    connect?: PessoaWhereUniqueInput
  }

  export type ReservaCreateNestedOneWithoutPessoaReservaInput = {
    create?: XOR<ReservaCreateWithoutPessoaReservaInput, ReservaUncheckedCreateWithoutPessoaReservaInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPessoaReservaInput
    connect?: ReservaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutPessoaReservaNestedInput = {
    create?: XOR<PessoaCreateWithoutPessoaReservaInput, PessoaUncheckedCreateWithoutPessoaReservaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaReservaInput
    upsert?: PessoaUpsertWithoutPessoaReservaInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutPessoaReservaInput, PessoaUncheckedUpdateWithoutPessoaReservaInput>
  }

  export type ReservaUpdateOneRequiredWithoutPessoaReservaNestedInput = {
    create?: XOR<ReservaCreateWithoutPessoaReservaInput, ReservaUncheckedCreateWithoutPessoaReservaInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPessoaReservaInput
    upsert?: ReservaUpsertWithoutPessoaReservaInput
    connect?: ReservaWhereUniqueInput
    update?: XOR<ReservaUpdateWithoutPessoaReservaInput, ReservaUncheckedUpdateWithoutPessoaReservaInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type VeiculoCreateWithoutTipoVeiculoInput = {
    Motorista: PessoaCreateNestedOneWithoutVeiculoInput
    Apelido: string
    Reserva?: ReservaCreateNestedManyWithoutVeiculoInput
  }

  export type VeiculoUncheckedCreateWithoutTipoVeiculoInput = {
    Id?: number
    IdMotorista: number
    Apelido: string
    Reserva?: ReservaUncheckedCreateNestedManyWithoutVeiculoInput
  }

  export type VeiculoCreateOrConnectWithoutTipoVeiculoInput = {
    where: VeiculoWhereUniqueInput
    create: XOR<VeiculoCreateWithoutTipoVeiculoInput, VeiculoUncheckedCreateWithoutTipoVeiculoInput>
  }

  export type VeiculoCreateManyTipoVeiculoInputEnvelope = {
    data: Enumerable<VeiculoCreateManyTipoVeiculoInput>
    skipDuplicates?: boolean
  }

  export type VeiculoUpsertWithWhereUniqueWithoutTipoVeiculoInput = {
    where: VeiculoWhereUniqueInput
    update: XOR<VeiculoUpdateWithoutTipoVeiculoInput, VeiculoUncheckedUpdateWithoutTipoVeiculoInput>
    create: XOR<VeiculoCreateWithoutTipoVeiculoInput, VeiculoUncheckedCreateWithoutTipoVeiculoInput>
  }

  export type VeiculoUpdateWithWhereUniqueWithoutTipoVeiculoInput = {
    where: VeiculoWhereUniqueInput
    data: XOR<VeiculoUpdateWithoutTipoVeiculoInput, VeiculoUncheckedUpdateWithoutTipoVeiculoInput>
  }

  export type VeiculoUpdateManyWithWhereWithoutTipoVeiculoInput = {
    where: VeiculoScalarWhereInput
    data: XOR<VeiculoUpdateManyMutationInput, VeiculoUncheckedUpdateManyWithoutVeiculosInput>
  }

  export type VeiculoScalarWhereInput = {
    AND?: Enumerable<VeiculoScalarWhereInput>
    OR?: Enumerable<VeiculoScalarWhereInput>
    NOT?: Enumerable<VeiculoScalarWhereInput>
    Id?: IntFilter | number
    IdTipoVeiculo?: IntFilter | number
    IdMotorista?: IntFilter | number
    Apelido?: StringFilter | string
  }

  export type VeiculoCreateWithoutMotoristaInput = {
    TipoVeiculo: TipoVeiculoCreateNestedOneWithoutVeiculosInput
    Apelido: string
    Reserva?: ReservaCreateNestedManyWithoutVeiculoInput
  }

  export type VeiculoUncheckedCreateWithoutMotoristaInput = {
    Id?: number
    IdTipoVeiculo: number
    Apelido: string
    Reserva?: ReservaUncheckedCreateNestedManyWithoutVeiculoInput
  }

  export type VeiculoCreateOrConnectWithoutMotoristaInput = {
    where: VeiculoWhereUniqueInput
    create: XOR<VeiculoCreateWithoutMotoristaInput, VeiculoUncheckedCreateWithoutMotoristaInput>
  }

  export type VeiculoCreateManyMotoristaInputEnvelope = {
    data: Enumerable<VeiculoCreateManyMotoristaInput>
    skipDuplicates?: boolean
  }

  export type PessoaReservaCreateWithoutPessoaInput = {
    Reserva: ReservaCreateNestedOneWithoutPessoaReservaInput
  }

  export type PessoaReservaUncheckedCreateWithoutPessoaInput = {
    Id?: number
    IdReserva: number
  }

  export type PessoaReservaCreateOrConnectWithoutPessoaInput = {
    where: PessoaReservaWhereUniqueInput
    create: XOR<PessoaReservaCreateWithoutPessoaInput, PessoaReservaUncheckedCreateWithoutPessoaInput>
  }

  export type PessoaReservaCreateManyPessoaInputEnvelope = {
    data: Enumerable<PessoaReservaCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type VeiculoUpsertWithWhereUniqueWithoutMotoristaInput = {
    where: VeiculoWhereUniqueInput
    update: XOR<VeiculoUpdateWithoutMotoristaInput, VeiculoUncheckedUpdateWithoutMotoristaInput>
    create: XOR<VeiculoCreateWithoutMotoristaInput, VeiculoUncheckedCreateWithoutMotoristaInput>
  }

  export type VeiculoUpdateWithWhereUniqueWithoutMotoristaInput = {
    where: VeiculoWhereUniqueInput
    data: XOR<VeiculoUpdateWithoutMotoristaInput, VeiculoUncheckedUpdateWithoutMotoristaInput>
  }

  export type VeiculoUpdateManyWithWhereWithoutMotoristaInput = {
    where: VeiculoScalarWhereInput
    data: XOR<VeiculoUpdateManyMutationInput, VeiculoUncheckedUpdateManyWithoutVeiculoInput>
  }

  export type PessoaReservaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: PessoaReservaWhereUniqueInput
    update: XOR<PessoaReservaUpdateWithoutPessoaInput, PessoaReservaUncheckedUpdateWithoutPessoaInput>
    create: XOR<PessoaReservaCreateWithoutPessoaInput, PessoaReservaUncheckedCreateWithoutPessoaInput>
  }

  export type PessoaReservaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: PessoaReservaWhereUniqueInput
    data: XOR<PessoaReservaUpdateWithoutPessoaInput, PessoaReservaUncheckedUpdateWithoutPessoaInput>
  }

  export type PessoaReservaUpdateManyWithWhereWithoutPessoaInput = {
    where: PessoaReservaScalarWhereInput
    data: XOR<PessoaReservaUpdateManyMutationInput, PessoaReservaUncheckedUpdateManyWithoutPessoaReservaInput>
  }

  export type PessoaReservaScalarWhereInput = {
    AND?: Enumerable<PessoaReservaScalarWhereInput>
    OR?: Enumerable<PessoaReservaScalarWhereInput>
    NOT?: Enumerable<PessoaReservaScalarWhereInput>
    Id?: IntFilter | number
    IdPessoa?: IntFilter | number
    IdReserva?: IntFilter | number
  }

  export type TipoVeiculoCreateWithoutVeiculosInput = {
    Descricao: string
    QtdeLugares: number
  }

  export type TipoVeiculoUncheckedCreateWithoutVeiculosInput = {
    Id?: number
    Descricao: string
    QtdeLugares: number
  }

  export type TipoVeiculoCreateOrConnectWithoutVeiculosInput = {
    where: TipoVeiculoWhereUniqueInput
    create: XOR<TipoVeiculoCreateWithoutVeiculosInput, TipoVeiculoUncheckedCreateWithoutVeiculosInput>
  }

  export type PessoaCreateWithoutVeiculoInput = {
    Nome: string
    Apelido: string
    Celular: string
    PessoaReserva?: PessoaReservaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutVeiculoInput = {
    Id?: number
    Nome: string
    Apelido: string
    Celular: string
    PessoaReserva?: PessoaReservaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutVeiculoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutVeiculoInput, PessoaUncheckedCreateWithoutVeiculoInput>
  }

  export type ReservaCreateWithoutVeiculoInput = {
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
    PessoaReserva?: PessoaReservaCreateNestedManyWithoutReservaInput
  }

  export type ReservaUncheckedCreateWithoutVeiculoInput = {
    Id?: number
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
    PessoaReserva?: PessoaReservaUncheckedCreateNestedManyWithoutReservaInput
  }

  export type ReservaCreateOrConnectWithoutVeiculoInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutVeiculoInput, ReservaUncheckedCreateWithoutVeiculoInput>
  }

  export type ReservaCreateManyVeiculoInputEnvelope = {
    data: Enumerable<ReservaCreateManyVeiculoInput>
    skipDuplicates?: boolean
  }

  export type TipoVeiculoUpsertWithoutVeiculosInput = {
    update: XOR<TipoVeiculoUpdateWithoutVeiculosInput, TipoVeiculoUncheckedUpdateWithoutVeiculosInput>
    create: XOR<TipoVeiculoCreateWithoutVeiculosInput, TipoVeiculoUncheckedCreateWithoutVeiculosInput>
  }

  export type TipoVeiculoUpdateWithoutVeiculosInput = {
    Descricao?: StringFieldUpdateOperationsInput | string
    QtdeLugares?: IntFieldUpdateOperationsInput | number
  }

  export type TipoVeiculoUncheckedUpdateWithoutVeiculosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Descricao?: StringFieldUpdateOperationsInput | string
    QtdeLugares?: IntFieldUpdateOperationsInput | number
  }

  export type PessoaUpsertWithoutVeiculoInput = {
    update: XOR<PessoaUpdateWithoutVeiculoInput, PessoaUncheckedUpdateWithoutVeiculoInput>
    create: XOR<PessoaCreateWithoutVeiculoInput, PessoaUncheckedCreateWithoutVeiculoInput>
  }

  export type PessoaUpdateWithoutVeiculoInput = {
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
    PessoaReserva?: PessoaReservaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutVeiculoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
    PessoaReserva?: PessoaReservaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type ReservaUpsertWithWhereUniqueWithoutVeiculoInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutVeiculoInput, ReservaUncheckedUpdateWithoutVeiculoInput>
    create: XOR<ReservaCreateWithoutVeiculoInput, ReservaUncheckedCreateWithoutVeiculoInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutVeiculoInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutVeiculoInput, ReservaUncheckedUpdateWithoutVeiculoInput>
  }

  export type ReservaUpdateManyWithWhereWithoutVeiculoInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutReservaInput>
  }

  export type ReservaScalarWhereInput = {
    AND?: Enumerable<ReservaScalarWhereInput>
    OR?: Enumerable<ReservaScalarWhereInput>
    NOT?: Enumerable<ReservaScalarWhereInput>
    Id?: IntFilter | number
    IdVeiculo?: IntFilter | number
    QtdeLugaresOcupados?: IntFilter | number
    DataHoraSaida?: DateTimeFilter | Date | string
    DataReserva?: DateTimeFilter | Date | string
    DataHoraChegadaPrevista?: DateTimeFilter | Date | string
    Tolerancia?: FloatFilter | number
  }

  export type VeiculoCreateWithoutReservaInput = {
    TipoVeiculo: TipoVeiculoCreateNestedOneWithoutVeiculosInput
    Motorista: PessoaCreateNestedOneWithoutVeiculoInput
    Apelido: string
  }

  export type VeiculoUncheckedCreateWithoutReservaInput = {
    Id?: number
    IdTipoVeiculo: number
    IdMotorista: number
    Apelido: string
  }

  export type VeiculoCreateOrConnectWithoutReservaInput = {
    where: VeiculoWhereUniqueInput
    create: XOR<VeiculoCreateWithoutReservaInput, VeiculoUncheckedCreateWithoutReservaInput>
  }

  export type PessoaReservaCreateWithoutReservaInput = {
    Pessoa: PessoaCreateNestedOneWithoutPessoaReservaInput
  }

  export type PessoaReservaUncheckedCreateWithoutReservaInput = {
    Id?: number
    IdPessoa: number
  }

  export type PessoaReservaCreateOrConnectWithoutReservaInput = {
    where: PessoaReservaWhereUniqueInput
    create: XOR<PessoaReservaCreateWithoutReservaInput, PessoaReservaUncheckedCreateWithoutReservaInput>
  }

  export type PessoaReservaCreateManyReservaInputEnvelope = {
    data: Enumerable<PessoaReservaCreateManyReservaInput>
    skipDuplicates?: boolean
  }

  export type VeiculoUpsertWithoutReservaInput = {
    update: XOR<VeiculoUpdateWithoutReservaInput, VeiculoUncheckedUpdateWithoutReservaInput>
    create: XOR<VeiculoCreateWithoutReservaInput, VeiculoUncheckedCreateWithoutReservaInput>
  }

  export type VeiculoUpdateWithoutReservaInput = {
    TipoVeiculo?: TipoVeiculoUpdateOneRequiredWithoutVeiculosNestedInput
    Motorista?: PessoaUpdateOneRequiredWithoutVeiculoNestedInput
    Apelido?: StringFieldUpdateOperationsInput | string
  }

  export type VeiculoUncheckedUpdateWithoutReservaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdTipoVeiculo?: IntFieldUpdateOperationsInput | number
    IdMotorista?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaReservaUpsertWithWhereUniqueWithoutReservaInput = {
    where: PessoaReservaWhereUniqueInput
    update: XOR<PessoaReservaUpdateWithoutReservaInput, PessoaReservaUncheckedUpdateWithoutReservaInput>
    create: XOR<PessoaReservaCreateWithoutReservaInput, PessoaReservaUncheckedCreateWithoutReservaInput>
  }

  export type PessoaReservaUpdateWithWhereUniqueWithoutReservaInput = {
    where: PessoaReservaWhereUniqueInput
    data: XOR<PessoaReservaUpdateWithoutReservaInput, PessoaReservaUncheckedUpdateWithoutReservaInput>
  }

  export type PessoaReservaUpdateManyWithWhereWithoutReservaInput = {
    where: PessoaReservaScalarWhereInput
    data: XOR<PessoaReservaUpdateManyMutationInput, PessoaReservaUncheckedUpdateManyWithoutPessoaReservaInput>
  }

  export type PessoaCreateWithoutPessoaReservaInput = {
    Nome: string
    Apelido: string
    Celular: string
    Veiculo?: VeiculoCreateNestedManyWithoutMotoristaInput
  }

  export type PessoaUncheckedCreateWithoutPessoaReservaInput = {
    Id?: number
    Nome: string
    Apelido: string
    Celular: string
    Veiculo?: VeiculoUncheckedCreateNestedManyWithoutMotoristaInput
  }

  export type PessoaCreateOrConnectWithoutPessoaReservaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutPessoaReservaInput, PessoaUncheckedCreateWithoutPessoaReservaInput>
  }

  export type ReservaCreateWithoutPessoaReservaInput = {
    Veiculo: VeiculoCreateNestedOneWithoutReservaInput
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
  }

  export type ReservaUncheckedCreateWithoutPessoaReservaInput = {
    Id?: number
    IdVeiculo: number
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
  }

  export type ReservaCreateOrConnectWithoutPessoaReservaInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutPessoaReservaInput, ReservaUncheckedCreateWithoutPessoaReservaInput>
  }

  export type PessoaUpsertWithoutPessoaReservaInput = {
    update: XOR<PessoaUpdateWithoutPessoaReservaInput, PessoaUncheckedUpdateWithoutPessoaReservaInput>
    create: XOR<PessoaCreateWithoutPessoaReservaInput, PessoaUncheckedCreateWithoutPessoaReservaInput>
  }

  export type PessoaUpdateWithoutPessoaReservaInput = {
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
    Veiculo?: VeiculoUpdateManyWithoutMotoristaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutPessoaReservaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nome?: StringFieldUpdateOperationsInput | string
    Apelido?: StringFieldUpdateOperationsInput | string
    Celular?: StringFieldUpdateOperationsInput | string
    Veiculo?: VeiculoUncheckedUpdateManyWithoutMotoristaNestedInput
  }

  export type ReservaUpsertWithoutPessoaReservaInput = {
    update: XOR<ReservaUpdateWithoutPessoaReservaInput, ReservaUncheckedUpdateWithoutPessoaReservaInput>
    create: XOR<ReservaCreateWithoutPessoaReservaInput, ReservaUncheckedCreateWithoutPessoaReservaInput>
  }

  export type ReservaUpdateWithoutPessoaReservaInput = {
    Veiculo?: VeiculoUpdateOneRequiredWithoutReservaNestedInput
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
  }

  export type ReservaUncheckedUpdateWithoutPessoaReservaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdVeiculo?: IntFieldUpdateOperationsInput | number
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
  }

  export type VeiculoCreateManyTipoVeiculoInput = {
    Id?: number
    IdMotorista: number
    Apelido: string
  }

  export type VeiculoUpdateWithoutTipoVeiculoInput = {
    Motorista?: PessoaUpdateOneRequiredWithoutVeiculoNestedInput
    Apelido?: StringFieldUpdateOperationsInput | string
    Reserva?: ReservaUpdateManyWithoutVeiculoNestedInput
  }

  export type VeiculoUncheckedUpdateWithoutTipoVeiculoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdMotorista?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
    Reserva?: ReservaUncheckedUpdateManyWithoutVeiculoNestedInput
  }

  export type VeiculoUncheckedUpdateManyWithoutVeiculosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdMotorista?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
  }

  export type VeiculoCreateManyMotoristaInput = {
    Id?: number
    IdTipoVeiculo: number
    Apelido: string
  }

  export type PessoaReservaCreateManyPessoaInput = {
    Id?: number
    IdReserva: number
  }

  export type VeiculoUpdateWithoutMotoristaInput = {
    TipoVeiculo?: TipoVeiculoUpdateOneRequiredWithoutVeiculosNestedInput
    Apelido?: StringFieldUpdateOperationsInput | string
    Reserva?: ReservaUpdateManyWithoutVeiculoNestedInput
  }

  export type VeiculoUncheckedUpdateWithoutMotoristaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdTipoVeiculo?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
    Reserva?: ReservaUncheckedUpdateManyWithoutVeiculoNestedInput
  }

  export type VeiculoUncheckedUpdateManyWithoutVeiculoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdTipoVeiculo?: IntFieldUpdateOperationsInput | number
    Apelido?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaReservaUpdateWithoutPessoaInput = {
    Reserva?: ReservaUpdateOneRequiredWithoutPessoaReservaNestedInput
  }

  export type PessoaReservaUncheckedUpdateWithoutPessoaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdReserva?: IntFieldUpdateOperationsInput | number
  }

  export type PessoaReservaUncheckedUpdateManyWithoutPessoaReservaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdReserva?: IntFieldUpdateOperationsInput | number
  }

  export type ReservaCreateManyVeiculoInput = {
    Id?: number
    QtdeLugaresOcupados: number
    DataHoraSaida: Date | string
    DataReserva: Date | string
    DataHoraChegadaPrevista: Date | string
    Tolerancia: number
  }

  export type ReservaUpdateWithoutVeiculoInput = {
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
    PessoaReserva?: PessoaReservaUpdateManyWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateWithoutVeiculoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
    PessoaReserva?: PessoaReservaUncheckedUpdateManyWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateManyWithoutReservaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    QtdeLugaresOcupados?: IntFieldUpdateOperationsInput | number
    DataHoraSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    DataReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    DataHoraChegadaPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    Tolerancia?: FloatFieldUpdateOperationsInput | number
  }

  export type PessoaReservaCreateManyReservaInput = {
    Id?: number
    IdPessoa: number
  }

  export type PessoaReservaUpdateWithoutReservaInput = {
    Pessoa?: PessoaUpdateOneRequiredWithoutPessoaReservaNestedInput
  }

  export type PessoaReservaUncheckedUpdateWithoutReservaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    IdPessoa?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}